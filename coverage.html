
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>commands: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">conflux/cmd/conflux/commands/client_factory.go (0.0%)</option>
				
				<option value="file1">conflux/cmd/conflux/commands/get_page.go (44.3%)</option>
				
				<option value="file2">conflux/cmd/conflux/commands/inspect.go (84.9%)</option>
				
				<option value="file3">conflux/cmd/conflux/commands/list_pages.go (85.7%)</option>
				
				<option value="file4">conflux/cmd/conflux/commands/projects.go (90.9%)</option>
				
				<option value="file5">conflux/cmd/conflux/commands/root.go (40.0%)</option>
				
				<option value="file6">conflux/cmd/conflux/commands/sync.go (20.9%)</option>
				
				<option value="file7">conflux/cmd/conflux/commands/version.go (28.6%)</option>
				
				<option value="file8">conflux/cmd/conflux/main.go (0.0%)</option>
				
				<option value="file9">conflux/internal/config/config.go (81.8%)</option>
				
				<option value="file10">conflux/internal/confluence/client.go (77.2%)</option>
				
				<option value="file11">conflux/internal/confluence/mock.go (0.0%)</option>
				
				<option value="file12">conflux/internal/images/processor.go (52.5%)</option>
				
				<option value="file13">conflux/internal/markdown/parser.go (80.8%)</option>
				
				<option value="file14">conflux/internal/mermaid/processor.go (50.0%)</option>
				
				<option value="file15">conflux/internal/sync/metadata.go (76.3%)</option>
				
				<option value="file16">conflux/internal/sync/prompt.go (0.0%)</option>
				
				<option value="file17">conflux/internal/sync/rename_detection.go (60.4%)</option>
				
				<option value="file18">conflux/internal/sync/syncer.go (65.5%)</option>
				
				<option value="file19">conflux/pkg/logger/logger.go (80.0%)</option>
				
				<option value="file20">conflux/pkg/version/version.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package commands

import (
        "conflux/internal/confluence"
        "conflux/pkg/logger"
)

// newConfluenceClient is a package-level variable to allow test injection of a mock.
// Production code uses the real client constructor; tests can override this.
var newConfluenceClient = func(baseURL, user, token string, log *logger.Logger) confluence.ConfluenceClient <span class="cov0" title="0">{
        return confluence.NewClient(baseURL, user, token, log)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package commands

import (
        "fmt"
        "html"
        "io"
        "net/http"
        "net/url"
        "os"
        "regexp"
        "strings"

        htmldoc "github.com/JohannesKaufmann/html-to-markdown/v2"
        "github.com/spf13/cobra"

        "conflux/internal/config"
        "conflux/internal/confluence"
        "conflux/pkg/logger"
)

// preprocessConfluenceImages replaces &lt;ac:image&gt;&lt;ri:attachment ... /&gt;&lt;/ac:image&gt; with markdown image syntax
func preprocessConfluenceImages(html string) string <span class="cov8" title="1">{
        // Improved regex to match &lt;ac:image ...&gt;&lt;ri:attachment ri:filename="..." ... /&gt;&lt;/ac:image&gt;
        imgRe := regexp.MustCompile(`(?s)&lt;ac:image[^&gt;]*&gt;\s*&lt;ri:attachment[^&gt;]*ri:filename=["']([^"']+)["'][^&gt;]*/?&gt;\s*&lt;/ac:image&gt;`) // strict for single attachment
        return imgRe.ReplaceAllStringFunc(html, func(match string) string </span><span class="cov0" title="0">{
                filenameMatch := imgRe.FindStringSubmatch(match)
                var filename string
                if len(filenameMatch) &gt; 1 </span><span class="cov0" title="0">{
                        filename = filenameMatch[1]
                }</span> else<span class="cov0" title="0"> {
                        // Fallback: manual search for ri:filename="..."
                        idx := strings.Index(match, `ri:filename="`)
                        if idx != -1 </span><span class="cov0" title="0">{
                                start := idx + len(`ri:filename="`)
                                end := strings.Index(match[start:], `"`)
                                if end != -1 </span><span class="cov0" title="0">{
                                        filename = match[start : start+end]
                                }</span>
                        }
                }
                <span class="cov0" title="0">if filename != "" </span><span class="cov0" title="0">{
                        // URL-encode spaces
                        link := url.PathEscape(filename)
                        return fmt.Sprintf("![%s](attachments/%s)", filename, link)
                }</span>
                <span class="cov0" title="0">return ""</span>
        })
}

var (
        getPageSpace     string
        getPageIDOrTitle string
        getPageFormat    string
        getPageProject   string
)

// getPageCmd returns the raw page storage content for a page
var getPageCmd = &amp;cobra.Command{
        Use:   "get-page",
        Short: "Return the contents of a Confluence page",
        Long: `Fetch the storage-format content of a Confluence page by ID or title.

You must provide either:
  - a space key via --space, or
  - a project via --project (space inferred from project)

Then specify either a numeric page ID or a page title with --page.`,
        Example: `  conflux get-page -space DOCS -page 123456789
  conflux get-page -space DOCS -page "My Page Title"`,
        RunE: runGetPage,
}

func runGetPage(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        if getPageIDOrTitle == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("page flag is required for get-page command")
        }</span>

        // Validate format
        <span class="cov8" title="1">switch getPageFormat </span>{
        case "", "storage", "html", "markdown":<span class="cov8" title="1"></span>
                // ok (empty treated as storage)
        default:<span class="cov8" title="1">
                return fmt.Errorf("unsupported format: %s", getPageFormat)</span>
        }

        <span class="cov8" title="1">log := logger.New(verbose)

        cfg, err := config.LoadForListPages(configFile)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Project selection if provided
        <span class="cov8" title="1">if getPageProject != "" </span><span class="cov8" title="1">{
                if err := cfg.SelectProject(getPageProject); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to select project: %w", err)
                }</span>
                <span class="cov0" title="0">if getPageSpace == "" </span><span class="cov0" title="0">{
                        getPageSpace = cfg.Confluence.SpaceKey
                }</span>
        }
        <span class="cov8" title="1">if getPageSpace == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("space flag or --project required for get-page command")
        }</span>

        <span class="cov8" title="1">client := newConfluenceClient(cfg.Confluence.BaseURL, cfg.Confluence.Username, cfg.Confluence.APIToken, log)

        var page *confluence.Page

        // Try by ID if input looks numeric
        if isNumeric(getPageIDOrTitle) </span><span class="cov8" title="1">{
                page, err = client.GetPage(getPageIDOrTitle)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug("failed to get page by ID: %v", err)
                        page = nil
                }</span>
        }

        // If not found by ID, try by title
        <span class="cov8" title="1">if page == nil </span><span class="cov8" title="1">{
                page, err = client.FindPageByTitle(getPageSpace, getPageIDOrTitle)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find page by title: %w", err)
                }</span>
        }

        <span class="cov8" title="1">if page == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("page '%s' not found in space '%s'", getPageIDOrTitle, getPageSpace)
        }</span>

        // Print header then the requested format
        <span class="cov8" title="1">fmt.Printf("# %s (ID: %s)\n\n", page.Title, page.ID)

        format := getPageFormat
        if format == "" </span><span class="cov0" title="0">{
                format = "storage"
        }</span>

        <span class="cov8" title="1">content, err := generatePageOutput(page, format)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Download attachments and update markdown
        <span class="cov8" title="1">attachments, err := client.ListAttachments(page.ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Debug("failed to list attachments: %v", err)
                // Continue even if no attachments
        }</span>

        <span class="cov8" title="1">attachmentDir := "attachments"
        if len(attachments) &gt; 0 </span><span class="cov0" title="0">{
                if err := os.MkdirAll(attachmentDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create attachment directory: %w", err)
                }</span>
        }

        <span class="cov8" title="1">log.Debug("Found %d attachments for page %s", len(attachments), page.ID)
        for _, att := range attachments </span><span class="cov0" title="0">{
                log.Debug("Attachment: ID=%s Title=%s MediaType=%s Download=%s", att.ID, att.Title, att.MediaType, att.Links.Download)
                downloadURL, err := client.GetAttachmentDownloadURL(page.ID, att.ID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug("failed to get download URL for attachment %s: %v", att.Title, err)
                        continue</span>
                }
                <span class="cov0" title="0">localPath := fmt.Sprintf("%s/%s", attachmentDir, att.Title)
                req, err := http.NewRequest("GET", downloadURL, nil)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug("Failed to create request for attachment %s: %v", att.Title, err)
                        continue</span>
                }
                <span class="cov0" title="0">req.SetBasicAuth(cfg.Confluence.Username, cfg.Confluence.APIToken)
                realClient, ok := client.(*confluence.Client)
                if !ok </span><span class="cov0" title="0">{
                        log.Debug("Failed to access underlying HTTP client for attachment download")
                        continue</span>
                }
                <span class="cov0" title="0">resp, err := realClient.DoAuthenticatedRequest(req)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug("Failed to download attachment %s: %v", att.Title, err)
                        continue</span>
                }
                <span class="cov0" title="0">defer resp.Body.Close()
                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        body, _ := io.ReadAll(resp.Body)
                        log.Debug("Failed to download attachment %s: status %d, body: %s", att.Title, resp.StatusCode, string(body))
                        continue</span>
                }
                <span class="cov0" title="0">log.Debug("Saving attachment to %s", localPath)
                f, err := os.Create(localPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug("Failed to create local file for attachment %s: %v", att.Title, err)
                        continue</span>
                }
                <span class="cov0" title="0">_, err = io.Copy(f, resp.Body)
                f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug("Failed to save attachment %s: %v", att.Title, err)
                        continue</span>
                }
                // Replace inline markdown references
                <span class="cov0" title="0">if strings.HasPrefix(att.MediaType, "image/") </span>{<span class="cov0" title="0">
                        // Image macro replacement now handles inline links; no further replacement needed
                        // (If you need to support legacy or non-macro images, add logic here)
                }</span> else<span class="cov0" title="0"> {
                        // Replace all file references
                        content = strings.ReplaceAll(content, fmt.Sprintf("[%s]", att.Title), fmt.Sprintf("[%s](%s)", att.Title, localPath))
                        content = strings.ReplaceAll(content, fmt.Sprintf("[]( %s)", att.Title), fmt.Sprintf("[%s](%s)", att.Title, localPath))
                        content = strings.ReplaceAll(content, fmt.Sprintf("[]( %s)", localPath), fmt.Sprintf("[%s](%s)", att.Title, localPath))
                }</span>
        }

        <span class="cov8" title="1">fmt.Println(content)
        return nil</span>
}

func preprocessConfluenceMacros(htmlContent string) string <span class="cov8" title="1">{
        // Handle TOC macro
        tocRe := regexp.MustCompile(`(?s)&lt;ac:structured-macro ac:name="toc".*?/&gt;`)
        htmlContent = tocRe.ReplaceAllString(htmlContent, "") // Remove TOC macro

        // Handle Info and Note macros
        infoNoteRe := regexp.MustCompile(`(?s)&lt;ac:structured-macro ac:name="(info|note)".*?&gt;&lt;ac:rich-text-body&gt;(.*?)&lt;/ac:rich-text-body&gt;&lt;/ac:structured-macro&gt;`)
        htmlContent = infoNoteRe.ReplaceAllStringFunc(htmlContent, func(match string) string </span><span class="cov0" title="0">{
                // Extract content from ac:rich-text-body
                contentRe := regexp.MustCompile(`(?s)&lt;ac:rich-text-body&gt;(.*?)&lt;/ac:rich-text-body&gt;`)
                contentMatch := contentRe.FindStringSubmatch(match)
                content := ""
                if len(contentMatch) &gt; 1 </span><span class="cov0" title="0">{
                        content = contentMatch[1]
                }</span>
                // Un-escape &amp;gt;
                <span class="cov0" title="0">content = strings.ReplaceAll(content, "&amp;gt;", "&gt;")
                // Convert to blockquote
                return "\n&gt; " + strings.ReplaceAll(content, "\n", "\n&gt; ") + "\n"</span>
        })

        // Handle Inline Comment Marker macro (remove it)
        <span class="cov8" title="1">inlineCommentRe := regexp.MustCompile(`(?s)&lt;ac:inline-comment-marker.*?&gt;.*?&lt;/ac:inline-comment-marker&gt;`)
        htmlContent = inlineCommentRe.ReplaceAllString(htmlContent, "")

        // Handle View File macro
        viewFileRe := regexp.MustCompile(`(?s)&lt;ac:structured-macro ac:name="view-file".*?&gt;&lt;ac:parameter ac:name="name"&gt;&lt;ri:attachment ri:filename="(.*?)".*? /&gt;&lt;/ac:parameter&gt;&lt;/ac:structured-macro&gt;`)
        htmlContent = viewFileRe.ReplaceAllStringFunc(htmlContent, func(match string) string </span><span class="cov0" title="0">{
                filenameRe := regexp.MustCompile(`ri:filename="(.*?)"`)
                filenameMatch := filenameRe.FindStringSubmatch(match)
                filename := ""
                if len(filenameMatch) &gt; 1 </span><span class="cov0" title="0">{
                        filename = filenameMatch[1]
                }</span>
                // Create a markdown link to the attachment
                <span class="cov0" title="0">return fmt.Sprintf("[%s](attachments/%s)", filename, url.PathEscape(filename))</span>
        })

        // Handle Code macro
        <span class="cov8" title="1">codeRe := regexp.MustCompile(`(?s)&lt;ac:structured-macro ac:name="code".*?&gt;(.*?)&lt;/ac:structured-macro&gt;`)
        htmlContent = codeRe.ReplaceAllStringFunc(htmlContent, func(match string) string </span><span class="cov0" title="0">{
                // Extract language
                langRe := regexp.MustCompile(`&lt;ac:parameter ac:name="language"&gt;(.*?)&lt;/ac:parameter&gt;`)
                langMatch := langRe.FindStringSubmatch(match)
                language := ""
                if len(langMatch) &gt; 1 </span><span class="cov0" title="0">{
                        language = ` class="language-` + langMatch[1] + `"`
                }</span>

                // Extract code
                <span class="cov0" title="0">cdataRe := regexp.MustCompile(`(?s)&lt;!\[CDATA\[(.*?)]]&gt;`)
                cdataMatch := cdataRe.FindStringSubmatch(match)
                code := ""
                if len(cdataMatch) &gt; 1 </span><span class="cov0" title="0">{
                        code = html.EscapeString(cdataMatch[1])
                }</span>

                <span class="cov0" title="0">return "&lt;pre&gt;&lt;code" + language + "&gt;" + code + "&lt;/code&gt;&lt;/pre&gt;"</span>
        })

        <span class="cov8" title="1">return htmlContent</span>
}

// generatePageOutput returns the page content in the requested format.
// It does not include the header line with title/ID.
func generatePageOutput(page *confluence.Page, format string) (string, error) <span class="cov8" title="1">{
        switch format </span>{
        case "storage":<span class="cov8" title="1">
                return page.Body.Storage.Value, nil</span>
        case "html":<span class="cov8" title="1">
                if page.Body.View.Value != "" </span><span class="cov8" title="1">{
                        return page.Body.View.Value, nil
                }</span>
                <span class="cov8" title="1">return page.Body.Storage.Value, nil</span>
        case "markdown":<span class="cov8" title="1">
                var htmlContent string
                if page.Body.View.Value != "" </span><span class="cov8" title="1">{
                        htmlContent = page.Body.View.Value
                }</span> else<span class="cov8" title="1"> {
                        htmlContent = page.Body.Storage.Value
                }</span>
                // Preprocess Confluence image macros to markdown image syntax
                <span class="cov8" title="1">htmlContent = preprocessConfluenceImages(htmlContent)
                // Preprocess other Confluence macros
                htmlContent = preprocessConfluenceMacros(htmlContent)

                markdown, err := htmldoc.ConvertString(htmlContent)
                if err != nil </span><span class="cov0" title="0">{
                        return htmlContent, nil // fallback to raw HTML on conversion errors
                }</span>
                // Patch: unescape image syntax if needed
                <span class="cov8" title="1">patched := strings.ReplaceAll(string(markdown), "!\\\"[", "![")

                // New patch: unescape underscores in image URLs
                imgUrlRe := regexp.MustCompile(`!\[(.*?)\]\((.*?)\)`) 
                patched = imgUrlRe.ReplaceAllStringFunc(patched, func(match string) string </span><span class="cov0" title="0">{
                        parts := imgUrlRe.FindStringSubmatch(match)
                        altText := parts[1]
                        url := parts[2]
                        unescapedUrl := strings.ReplaceAll(url, "\\_", "_")
                        return fmt.Sprintf("![%s](%s)", altText, unescapedUrl)
                }</span>)

                // New patch: unescape &amp;gt; in blockquotes
                <span class="cov8" title="1">patched = strings.ReplaceAll(patched, "&amp;gt;", "&gt;")

                return patched, nil</span>
        default:<span class="cov8" title="1">
                return "", fmt.Errorf("unsupported format: %s", format)</span>
        }
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(getPageCmd)

        getPageCmd.Flags().StringVarP(&amp;getPageSpace, "space", "s", "", "Confluence space key (can be inferred from --project)")
        getPageCmd.Flags().StringVarP(&amp;getPageIDOrTitle, "page", "p", "", "Page title or ID to fetch (required)")
        getPageCmd.Flags().StringVarP(&amp;getPageFormat, "format", "f", "storage", "Output format: storage|html|markdown")
        getPageCmd.Flags().StringVarP(&amp;getPageProject, "project", "P", "", "Project name defined in config to infer space")

        if err := getPageCmd.MarkFlagRequired("page"); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to mark page flag as required: %v", err))</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package commands

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/spf13/cobra"

        "conflux/internal/config"
        "conflux/internal/confluence"
        "conflux/pkg/logger"
)

var (
        inspectSpace   string
        inspectPage    string
        showChildren   bool
        showParents    bool
        showDetails    bool
        inspectProject string
)

// inspectCmd represents the inspect command
var inspectCmd = &amp;cobra.Command{
        Use:   "inspect",
        Short: "Inspect page hierarchy and relationships in Confluence",
        Long: `Inspect page hierarchy and relationships in Confluence with detailed information.

This command helps debug page relationships and hierarchy issues by showing:
  - Page details (ID, title, parent information)
  - Children pages (if any)
  - Parent page chain (ancestors)
  - Page hierarchy visualization

Provide a space via --space or a project via --project (space inferred). You can specify a page by title or ID to start inspection from that page; if omitted an overview of the space roots is shown.`,
        Example: `  conflux inspect -space DOCS -page "My Page"        # Inspect by title
  conflux inspect -space DOCS -page "123456789"      # Inspect by ID  
  conflux inspect -space DOCS                       # Show space overview
  conflux inspect -space DOCS -page "Root" -details # Show detailed info`,
        RunE: runInspect,
}

func runInspect(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        log := logger.New(verbose)

        cfg, err := config.LoadForListPages(configFile)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Project selection if provided
        <span class="cov8" title="1">if inspectProject != "" </span><span class="cov8" title="1">{
                if err := cfg.SelectProject(inspectProject); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to select project: %w", err)
                }</span>
                <span class="cov0" title="0">if inspectSpace == "" </span><span class="cov0" title="0">{
                        inspectSpace = cfg.Confluence.SpaceKey
                }</span>
        }
        <span class="cov8" title="1">if inspectSpace == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("space flag or --project required for inspect command")
        }</span>

        <span class="cov8" title="1">client := newConfluenceClient(cfg.Confluence.BaseURL, cfg.Confluence.Username, cfg.Confluence.APIToken, log)

        // If no specific page requested, show space overview
        if inspectPage == "" </span><span class="cov8" title="1">{
                return inspectSpaceOverview(client, inspectSpace)
        }</span>

        // Try to find the page by ID or title
        <span class="cov8" title="1">var targetPage *confluence.Page

        // Check if the input looks like a page ID (numeric)
        if isNumeric(inspectPage) </span><span class="cov0" title="0">{
                log.Debug("Attempting to find page by ID: %s", inspectPage)
                targetPage, err = client.GetPage(inspectPage)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug("Failed to find page by ID, trying as title: %s", err)
                }</span>
        }

        // If not found by ID or input is not numeric, try by title
        <span class="cov8" title="1">if targetPage == nil </span><span class="cov8" title="1">{
                log.Debug("Attempting to find page by title: %s", inspectPage)
                targetPage, err = client.FindPageByTitle(inspectSpace, inspectPage)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find page by title: %w", err)
                }</span>
        }

        <span class="cov8" title="1">if targetPage == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("page '%s' not found in space '%s'", inspectPage, inspectSpace)
        }</span>

        <span class="cov8" title="1">return inspectPageDetails(client, targetPage, inspectSpace)</span>
}

func inspectSpaceOverview(client confluence.ConfluenceClient, spaceKey string) error <span class="cov8" title="1">{
        fmt.Printf("üè¢ Inspecting Space: %s\n", spaceKey)
        fmt.Println(strings.Repeat("=", 50))

        pages, err := client.GetPageHierarchy(spaceKey, "")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get page hierarchy: %w", err)
        }</span>

        <span class="cov8" title="1">if len(pages) == 0 </span><span class="cov0" title="0">{
                fmt.Println("üì≠ No pages found in this space")
                return nil
        }</span>

        <span class="cov8" title="1">fmt.Printf("üìä Found %d root pages in space\n\n", len(pages))

        // Show hierarchy
        printInspectPageTree(pages, 0, true)

        // Show summary
        totalPages := countTotalPages(pages)
        fmt.Printf("\nüìà Summary:\n")
        fmt.Printf("   üå≥ Root pages: %d\n", len(pages))
        fmt.Printf("   üìÑ Total pages: %d\n", totalPages)

        return nil</span>
}

func inspectPageDetails(client confluence.ConfluenceClient, page *confluence.Page, spaceKey string) error <span class="cov8" title="1">{
        fmt.Printf("üîç Inspecting Page: %s\n", page.Title)
        fmt.Println(strings.Repeat("=", 50))

        // Basic page information
        fmt.Printf("üìã Page Details:\n")
        fmt.Printf("   üÜî ID: %s\n", page.ID)
        fmt.Printf("   üìù Title: %s\n", page.Title)
        fmt.Printf("   üè¢ Space: %s\n", spaceKey)

        if showDetails </span><span class="cov8" title="1">{
                contentLength := len(page.Body.Storage.Value)
                fmt.Printf("   üìä Content Length: %d characters\n", contentLength)

                // Check for children macro
                hasChildrenMacro := strings.Contains(page.Body.Storage.Value, "ac:name=\"children\"")
                fmt.Printf("   üîó Has Children Macro: %v\n", hasChildrenMacro)

                if hasChildrenMacro </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚ÑπÔ∏è  This appears to be a directory page\n")
                }</span>
        }

        // Show parent chain (ancestors)
        <span class="cov8" title="1">fmt.Printf("\nüëÜ Parent Chain:\n")
        ancestors, err := client.GetPageAncestors(page.ID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("   ‚ùå Failed to get ancestors: %s\n", err)
        }</span> else<span class="cov8" title="1"> if len(ancestors) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("   üè† This is a root page (no parents)\n")
        }</span> else<span class="cov8" title="1"> {
                for i, ancestor := range ancestors </span><span class="cov8" title="1">{
                        fmt.Printf("   %s üìÅ %s (ID: %s)\n",
                                strings.Repeat("  ", i), ancestor.Title, ancestor.ID)
                }</span>
                <span class="cov8" title="1">fmt.Printf("   %s üìÑ %s (ID: %s) ‚Üê Current Page\n",
                        strings.Repeat("  ", len(ancestors)), page.Title, page.ID)</span>
        }

        // Show children
        <span class="cov8" title="1">fmt.Printf("\nüëá Children:\n")
        children, err := client.GetChildPages(page.ID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("   ‚ùå Failed to get children: %s\n", err)
        }</span> else<span class="cov8" title="1"> if len(children) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("   üì≠ No child pages\n")
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("   üìä Found %d child pages:\n", len(children))
                for _, child := range children </span><span class="cov8" title="1">{
                        fmt.Printf("     üìÑ %s (ID: %s)\n", child.Title, child.ID)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func printInspectPageTree(pages []confluence.PageInfo, indent int, isRoot bool) <span class="cov8" title="1">{
        for i, page := range pages </span><span class="cov8" title="1">{
                isLast := i == len(pages)-1

                // Build prefix with proper tree formatting
                prefix := ""
                if !isRoot </span><span class="cov8" title="1">{
                        for j := 0; j &lt; indent; j++ </span><span class="cov8" title="1">{
                                prefix += "  "
                        }</span>
                        <span class="cov8" title="1">if isLast </span><span class="cov8" title="1">{
                                prefix += "‚îî‚îÄ‚îÄ "
                        }</span> else<span class="cov0" title="0"> {
                                prefix += "‚îú‚îÄ‚îÄ "
                        }</span>
                }

                // Choose icon based on whether page has children
                <span class="cov8" title="1">var icon string
                if len(page.Children) &gt; 0 </span><span class="cov8" title="1">{
                        icon = "üìÅ"
                }</span> else<span class="cov8" title="1"> {
                        icon = "üìÑ"
                }</span>

                // Print the page with icon and ID
                <span class="cov8" title="1">if isRoot </span><span class="cov8" title="1">{
                        fmt.Printf("%s %s %s (ID: %s)\n", icon, prefix, page.Title, page.ID)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("%s%s %s (ID: %s)\n", prefix, icon, page.Title, page.ID)
                }</span>

                // Recursively print children
                <span class="cov8" title="1">if len(page.Children) &gt; 0 </span><span class="cov8" title="1">{
                        printInspectPageTree(page.Children, indent+1, false)
                }</span>
        }
}

func countTotalPages(pages []confluence.PageInfo) int <span class="cov8" title="1">{
        total := len(pages)
        for _, page := range pages </span><span class="cov8" title="1">{
                total += countTotalPages(page.Children)
        }</span>
        <span class="cov8" title="1">return total</span>
}

func isNumeric(s string) bool <span class="cov8" title="1">{
        _, err := strconv.ParseInt(s, 10, 64)
        return err == nil
}</span>

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(inspectCmd)

        // Local flags for inspect command
        inspectCmd.Flags().StringVarP(&amp;inspectSpace, "space", "s", "", "Confluence space key (can be inferred from --project)")
        inspectCmd.Flags().StringVarP(&amp;inspectPage, "page", "p", "", "Page title or ID to inspect (optional, shows space overview if omitted)")
        inspectCmd.Flags().BoolVar(&amp;showChildren, "children", true, "Show children pages (default: true)")
        inspectCmd.Flags().BoolVarP(&amp;showParents, "parents", "a", true, "Show parent chain/ancestors (default: true)")
        inspectCmd.Flags().BoolVarP(&amp;showDetails, "details", "d", false, "Show detailed page information")
        inspectCmd.Flags().StringVarP(&amp;inspectProject, "project", "P", "", "Project name defined in config to infer space")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package commands

import (
        "fmt"

        "github.com/spf13/cobra"

        "conflux/internal/config"
        "conflux/internal/confluence"
        "conflux/pkg/logger"
)

var (
        space       string
        parentPage  string
        listProject string
)

// listPagesCmd represents the list-pages command
var listPagesCmd = &amp;cobra.Command{
        Use:   "list-pages",
        Short: "List page hierarchy from a Confluence space",
        Long: `List page hierarchy from a Confluence space with visual tree formatting.

This command connects to Confluence and retrieves the page hierarchy for a specified
space, displaying it with icons and tree formatting for easy navigation:
  üè¢ Space indicators
  üìÅ Folders (pages with children)
  üìÑ Pages (leaf nodes)

You can optionally specify a parent page to start the hierarchy from.`,
        Example: `  conflux list-pages -space DOCS                     # List all pages in space
  conflux list-pages -space DOCS -parent "API"      # List pages under parent
  conflux list-pages -space TEAM -v                 # List with verbose logging`,
        RunE: runListPages,
}

func runListPages(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        log := logger.New(verbose)

        cfg, err := config.LoadForListPages(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Project selection if provided
        <span class="cov8" title="1">if listProject != "" </span><span class="cov8" title="1">{
                if err := cfg.SelectProject(listProject); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to select project: %w", err)
                }</span>
                <span class="cov0" title="0">if space == "" </span><span class="cov0" title="0">{
                        space = cfg.Confluence.SpaceKey
                }</span>
        }

        <span class="cov8" title="1">if space == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("space flag or --project required for list-pages command")
        }</span>

        <span class="cov8" title="1">client := newConfluenceClient(cfg.Confluence.BaseURL, cfg.Confluence.Username, cfg.Confluence.APIToken, log)

        pages, err := client.GetPageHierarchy(space, parentPage)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get page hierarchy: %w", err)
        }</span>

        <span class="cov8" title="1">if parentPage != "" </span><span class="cov0" title="0">{
                fmt.Printf("üè¢ Space '%s' ‚Üí üìÅ '%s':\n\n", space, parentPage)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("üè¢ Space '%s':\n\n", space)
        }</span>

        <span class="cov8" title="1">printPageTree(pages, 0, true)
        return nil</span>
}

func printPageTree(pages []confluence.PageInfo, indent int, isRoot bool) <span class="cov8" title="1">{
        for i, page := range pages </span><span class="cov8" title="1">{
                isLast := i == len(pages)-1

                // Build prefix with proper tree formatting
                prefix := ""
                if !isRoot </span><span class="cov8" title="1">{
                        for j := 0; j &lt; indent; j++ </span><span class="cov8" title="1">{
                                prefix += "  "
                        }</span>
                        <span class="cov8" title="1">if isLast </span><span class="cov8" title="1">{
                                prefix += "‚îî‚îÄ‚îÄ "
                        }</span> else<span class="cov0" title="0"> {
                                prefix += "‚îú‚îÄ‚îÄ "
                        }</span>
                }

                // Choose icon based on whether page has children
                <span class="cov8" title="1">var icon string
                if len(page.Children) &gt; 0 </span><span class="cov8" title="1">{
                        icon = "üìÅ"
                }</span> else<span class="cov8" title="1"> {
                        icon = "üìÑ"
                }</span>

                // Print the page with icon
                <span class="cov8" title="1">if isRoot </span><span class="cov8" title="1">{
                        fmt.Printf("%s %s %s (ID: %s)\n", icon, prefix, page.Title, page.ID)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("%s%s %s (ID: %s)\n", prefix, icon, page.Title, page.ID)
                }</span>

                // Recursively print children
                <span class="cov8" title="1">if len(page.Children) &gt; 0 </span><span class="cov8" title="1">{
                        printPageTree(page.Children, indent+1, false)
                }</span>
        }
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(listPagesCmd)

        // Local flags for list-pages command
        listPagesCmd.Flags().StringVarP(&amp;space, "space", "s", "", "Confluence space key (can be inferred from --project)")
        listPagesCmd.Flags().StringVarP(&amp;parentPage, "parent", "p", "", "Parent page title to start from (optional)")
        listPagesCmd.Flags().StringVarP(&amp;listProject, "project", "P", "", "Project name defined in config to infer space")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package commands

import (
        "fmt"
        "sort"

        "github.com/spf13/cobra"

        "conflux/internal/config"
)

var (
        projectsShowRaw bool
)

var projectsCmd = &amp;cobra.Command{
        Use:   "projects",
        Short: "List configured documentation projects",
        Long: `List projects defined in the configuration file. Shows the project name,
associated Confluence space key, and markdown directory. The first project is the
implicit default when none is specified with --project in other commands.`,
        RunE: runProjects,
}

func runProjects(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        cfg, err := config.Load(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov8" title="1">if len(cfg.Projects) == 0 </span><span class="cov8" title="1">{
                fmt.Fprintln(cmd.OutOrStdout(), "No projects defined (using legacy single-project configuration).")
                return nil
        }</span>

        // Stable order by name except keep original index for default indicator (index 0)
        <span class="cov8" title="1">projects := make([]config.ProjectConfig, len(cfg.Projects))
        copy(projects, cfg.Projects)
        sort.SliceStable(projects, func(i, j int) bool </span><span class="cov8" title="1">{ return projects[i].Name &lt; projects[j].Name }</span>)

        <span class="cov8" title="1">fmt.Fprintln(cmd.OutOrStdout(), "Configured Projects:")
        fmt.Fprintln(cmd.OutOrStdout())
        for _, p := range projects </span><span class="cov8" title="1">{
                defaultMarker := ""
                if cfg.Projects[0].Name == p.Name </span><span class="cov8" title="1">{ // original first remains default
                        defaultMarker = " (default)"
                }</span>
                <span class="cov8" title="1">fmt.Fprintf(cmd.OutOrStdout(), "- %s%s\n  space: %s\n  docs:  %s\n", p.Name, defaultMarker, p.SpaceKey, p.Local.MarkdownDir)
                if len(p.Local.Exclude) &gt; 0 &amp;&amp; projectsShowRaw </span><span class="cov0" title="0">{
                        fmt.Fprintf(cmd.OutOrStdout(), "  exclude: %v\n", p.Local.Exclude)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(projectsCmd)
        projectsCmd.Flags().BoolVar(&amp;projectsShowRaw, "show-exclude", false, "Show exclude patterns for each project")
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package commands

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
)

var (
        configFile string
        verbose    bool
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "conflux",
        Short: "Sync local markdown files to Confluence",
        Long: `Conflux is a tool for synchronizing local markdown files to Confluence pages.
It provides commands to sync documentation and list page hierarchies with visual 
formatting including icons and tree structures for easy navigation.`,
        Example: `  conflux sync                                    # Sync current directory
  conflux sync -docs ./docs -space DOCS -dry-run # Sync with options
  conflux list-pages -space DOCS                 # List all pages with icons
  conflux list-pages -space DOCS -parent "API"   # List under parent with tree view`,
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        // Global persistent flags available to all subcommands
        rootCmd.PersistentFlags().StringVarP(&amp;configFile, "config", "c", "config.yaml", "path to configuration file")
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "enable verbose logging")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package commands

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"

        "conflux/internal/config"
        "conflux/internal/sync"
        "conflux/pkg/logger"
)

var (
        dryRun        bool
        force         bool
        noCache       bool
        forceStubs    bool
        detectRenames bool
        docsDir       string
        spaceKey      string
        projectName   string
)

// syncCmd represents the sync command
var syncCmd = &amp;cobra.Command{
        Use:   "sync",
        Short: "Sync local markdown files to Confluence with change detection",
        Long: `Sync local markdown files to Confluence pages with intelligent change detection.

The sync command analyzes your markdown files, detects what has changed since the last sync,
and displays a preview of what will be updated before proceeding. It maintains a local cache
to track file changes and only updates pages that have actually been modified.

Space resolution precedence:
  1. --space flag
  2. --project flag (project's space)
  3. First project in config (implicit default, if space unset)
  4. Top-level confluence.space_key (legacy single-project)

When a project is selected, its markdown directory overrides the global one unless explicitly overridden with --docs.`,
        Example: `  conflux sync                                # Sync with change detection and confirmation
  conflux sync --dry-run                      # Preview changes without syncing  
  conflux sync --force                        # Skip confirmation prompts
  conflux sync --no-cache                     # Ignore cache, check all files
  conflux sync --detect-renames               # Only run rename detection analysis
  conflux sync --force-stubs                  # Force regenerate all directory stub pages
  conflux sync -docs ./documentation         # Sync specific directory
  conflux sync -docs ./docs/readme.md        # Sync single markdown file
  conflux sync -space DOCS -v                # Sync to specific space with verbose logging`,
        RunE: runSync,
}

func runSync(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        log := logger.New(verbose)

        cfg, err := config.LoadForSync(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Override config markdown directory with CLI flag
        // Handle single file vs directory logic
        <span class="cov0" title="0">var singleFilePath string
        if docsDir != "." </span><span class="cov0" title="0">{
                info, err := os.Stat(docsDir)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to access path %s: %w", docsDir, err)
                }</span>

                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        // Single file: set MarkdownDir to the parent directory and store the full file path
                        cfg.Local.MarkdownDir = filepath.Dir(docsDir)
                        singleFilePath = docsDir
                }</span> else<span class="cov0" title="0"> {
                        // Directory: use as-is
                        cfg.Local.MarkdownDir = docsDir
                }</span>
        }

        // Project selection logic (applied before space override)
        <span class="cov0" title="0">if projectName != "" </span><span class="cov0" title="0">{
                if err := cfg.SelectProject(projectName); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to select project: %w", err)
                }</span>
        } else<span class="cov0" title="0"> if cfg.Confluence.SpaceKey == "" &amp;&amp; len(cfg.Projects) &gt; 0 </span><span class="cov0" title="0">{
                // Auto-apply default (first) project if no global space key
                cfg.ApplyDefaultProject()
        }</span>

        // Override space key if provided via CLI flag (takes highest precedence)
        <span class="cov0" title="0">if spaceKey != "" </span><span class="cov0" title="0">{
                cfg.Confluence.SpaceKey = spaceKey
        }</span>

        // Validate that space key is available either from config, project, or CLI
        <span class="cov0" title="0">if cfg.Confluence.SpaceKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("space key is required: provide via config file, project, or use --space flag")
        }</span>

        <span class="cov0" title="0">syncer := sync.New(cfg, log)

        // Handle no-cache flag
        if noCache </span><span class="cov0" title="0">{
                if err := syncer.ClearCache(); err != nil </span><span class="cov0" title="0">{
                        log.Debug("Could not clear cache: %v", err)
                }</span>
        }

        // Handle detect-renames-only mode
        <span class="cov0" title="0">if detectRenames </span><span class="cov0" title="0">{
                if err := syncer.DetectRenamesOnly(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("rename detection failed: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">if err := syncer.SyncWithFile(dryRun, force, forceStubs, singleFilePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("sync failed: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Sync completed successfully!")
        return nil</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(syncCmd)

        // Local flags for sync command
        syncCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "perform a dry run without making changes")
        syncCmd.Flags().BoolVar(&amp;force, "force", false, "skip confirmation prompts and proceed with sync")
        syncCmd.Flags().BoolVar(&amp;noCache, "no-cache", false, "ignore cached change detection and check all files")
        syncCmd.Flags().BoolVar(&amp;detectRenames, "detect-renames", false, "only run rename detection analysis without syncing")
        syncCmd.Flags().BoolVar(&amp;forceStubs, "force-stubs", false, "force regeneration of all directory stub pages")
        syncCmd.Flags().StringVarP(&amp;docsDir, "docs", "d", ".", "path to local markdown directory or single .md file")
        syncCmd.Flags().StringVarP(&amp;spaceKey, "space", "s", "", "Confluence space key (overrides config/project)")
        syncCmd.Flags().StringVarP(&amp;projectName, "project", "P", "", "Project name defined in config (selects space &amp; docs dir)")
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package commands

import (
        "fmt"

        "github.com/spf13/cobra"

        "conflux/pkg/version"
)

var (
        shortVersion bool
)

// versionCmd represents the version command
var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Show version information",
        Long: `Display the version information for Conflux including build details.
        
The version command shows the current version of Conflux along with build
information such as Git commit, build date, Go version, and platform.`,
        Example: `  conflux version        # Show full version information
  conflux version --short # Show only version number`,
        RunE: runVersion,
}

func runVersion(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        buildInfo := version.Get()

        if shortVersion </span><span class="cov0" title="0">{
                fmt.Println(buildInfo.Version)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(buildInfo.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(versionCmd)

        // Local flags for version command
        versionCmd.Flags().BoolVar(&amp;shortVersion, "short", false, "show only version number")
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "conflux/cmd/conflux/commands"
)

func main() <span class="cov0" title="0">{
        commands.Execute()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package config

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

type Config struct {
        Confluence ConfluenceConfig `yaml:"confluence"`
        Local      LocalConfig      `yaml:"local"`    // Backward compatibility: single local section
        Projects   []ProjectConfig  `yaml:"projects"` // New multi-project support
        Mermaid    MermaidConfig    `yaml:"mermaid"`
        Images     ImageConfig      `yaml:"images"`
}

type ConfluenceConfig struct {
        BaseURL  string `yaml:"base_url"`
        Username string `yaml:"username"`
        APIToken string `yaml:"api_token"`
        SpaceKey string `yaml:"space_key"` // Optional when using projects
}

type LocalConfig struct {
        MarkdownDir string   `yaml:"markdown_dir"`
        Exclude     []string `yaml:"exclude"`
}

type MermaidConfig struct {
        Mode    string  `yaml:"mode"`     // "preserve" or "convert-to-image"
        Format  string  `yaml:"format"`   // "svg", "png", "pdf"
        CLIPath string  `yaml:"cli_path"` // path to mermaid CLI executable
        Theme   string  `yaml:"theme"`    // mermaid theme
        Width   int     `yaml:"width"`    // image width in pixels
        Height  int     `yaml:"height"`   // image height in pixels
        Scale   float64 `yaml:"scale"`    // puppeteer scale factor for higher resolution
}

type ImageConfig struct {
        SupportedFormats []string `yaml:"supported_formats"` // File extensions: png, jpg, jpeg, gif, svg, webp
        MaxFileSize      int64    `yaml:"max_file_size"`     // Maximum file size in bytes (default: 10MB)
        ResizeLarge      bool     `yaml:"resize_large"`      // Whether to resize large images
        MaxWidth         int      `yaml:"max_width"`         // Max width for resizing (default: 1200px)
        MaxHeight        int      `yaml:"max_height"`        // Max height for resizing (default: 800px)
}

// ProjectConfig defines an individual documentation project mapping local markdown to a Confluence space.
// Example YAML:
// projects:
//   - name: "docs"
//     space_key: "DOCS"
//     local:
//       markdown_dir: "./docs"
//       exclude: ["README.md"]
//
// Rules:
// - Project name must be unique and non-empty
// - space_key required per project
// - local.markdown_dir required per project
// - If projects list is non-empty, top-level confluence.space_key becomes optional
// - First project acts as default if none specified at runtime
// - Top-level Local + SpaceKey kept for backward compatibility (single project scenario)
// - Images/Mermaid settings remain global

type ProjectConfig struct {
        Name     string      `yaml:"name"`
        SpaceKey string      `yaml:"space_key"`
        Local    LocalConfig `yaml:"local"`
}

// ResolveConfigPath returns the path to use. If the provided path does not
// exist it falls back to XDG config (~/.config/conflux/config.yaml).
func ResolveConfigPath(path string) string <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                path = "config.yaml"
        }</span>
        <span class="cov8" title="1">if fileExists(path) </span><span class="cov8" title="1">{
                return path
        }</span>
        // Only attempt fallback if original path was relative (empty or not absolute)
        <span class="cov8" title="1">if !filepath.IsAbs(path) </span><span class="cov0" title="0">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return path // can't resolve home; return original (will error later)
                }</span>
                <span class="cov0" title="0">fallback := filepath.Join(home, ".config", "conflux", "config.yaml")
                if fileExists(fallback) </span><span class="cov0" title="0">{
                        return fallback
                }</span>
        }
        <span class="cov8" title="1">return path</span>
}

func fileExists(p string) bool <span class="cov8" title="1">{
        info, err := os.Stat(p)
        return err == nil &amp;&amp; !info.IsDir()
}</span>

func Load(path string) (*Config, error) <span class="cov8" title="1">{
        resolved := ResolveConfigPath(path)
        data, err := os.ReadFile(resolved)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        // Set defaults
        <span class="cov8" title="1">config.setMermaidDefaults()
        config.setImageDefaults()

        if err := config.validate(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid config: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;config, nil</span>
}

func (c *Config) setMermaidDefaults() <span class="cov8" title="1">{
        if c.Mermaid.Mode == "" </span><span class="cov8" title="1">{
                c.Mermaid.Mode = "convert-to-image"
        }</span>
        <span class="cov8" title="1">if c.Mermaid.Format == "" </span><span class="cov8" title="1">{
                c.Mermaid.Format = "svg"
        }</span>
        <span class="cov8" title="1">if c.Mermaid.CLIPath == "" </span><span class="cov8" title="1">{
                c.Mermaid.CLIPath = "mmdc"
        }</span>
        <span class="cov8" title="1">if c.Mermaid.Theme == "" </span><span class="cov8" title="1">{
                c.Mermaid.Theme = "default"
        }</span>
        <span class="cov8" title="1">if c.Mermaid.Width == 0 </span><span class="cov8" title="1">{
                c.Mermaid.Width = 1200
        }</span>
        <span class="cov8" title="1">if c.Mermaid.Height == 0 </span><span class="cov8" title="1">{
                c.Mermaid.Height = 800
        }</span>
        <span class="cov8" title="1">if c.Mermaid.Scale == 0 </span><span class="cov8" title="1">{
                c.Mermaid.Scale = 2.0
        }</span>
}

func (c *Config) setImageDefaults() <span class="cov8" title="1">{
        if len(c.Images.SupportedFormats) == 0 </span><span class="cov8" title="1">{
                c.Images.SupportedFormats = []string{"png", "jpg", "jpeg", "gif", "svg", "webp"}
        }</span>
        <span class="cov8" title="1">if c.Images.MaxFileSize == 0 </span><span class="cov8" title="1">{
                c.Images.MaxFileSize = 10 * 1024 * 1024
        }</span>
        <span class="cov8" title="1">if c.Images.MaxWidth == 0 </span><span class="cov8" title="1">{
                c.Images.MaxWidth = 1200
        }</span>
        <span class="cov8" title="1">if c.Images.MaxHeight == 0 </span><span class="cov8" title="1">{
                c.Images.MaxHeight = 800
        }</span>
}

func (c *Config) validateMermaid() error <span class="cov8" title="1">{
        validModes := map[string]bool{"preserve": true, "convert-to-image": true}
        if !validModes[c.Mermaid.Mode] </span><span class="cov8" title="1">{
                return fmt.Errorf("mermaid.mode must be 'preserve' or 'convert-to-image'")
        }</span>
        <span class="cov8" title="1">validFormats := map[string]bool{"svg": true, "png": true, "pdf": true}
        if !validFormats[c.Mermaid.Format] </span><span class="cov8" title="1">{
                return fmt.Errorf("mermaid.format must be 'svg', 'png', or 'pdf'")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (c *Config) validateImages() error <span class="cov8" title="1">{
        validFormats := map[string]bool{"png": true, "jpg": true, "jpeg": true, "gif": true, "svg": true, "webp": true}
        for _, format := range c.Images.SupportedFormats </span><span class="cov8" title="1">{
                if !validFormats[format] </span><span class="cov0" title="0">{
                        return fmt.Errorf("images.supported_formats contains invalid format '%s', must be one of: png, jpg, jpeg, gif, svg, webp", format)
                }</span>
        }
        <span class="cov8" title="1">if c.Images.MaxFileSize &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("images.max_file_size cannot be negative")
        }</span>
        <span class="cov8" title="1">if c.Images.MaxWidth &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("images.max_width cannot be negative")
        }</span>
        <span class="cov8" title="1">if c.Images.MaxHeight &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("images.max_height cannot be negative")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// LoadForSync loads config with relaxed validation for space_key (can be overridden by CLI or projects)
func LoadForSync(path string) (*Config, error) <span class="cov8" title="1">{
        resolved := ResolveConfigPath(path)
        data, err := os.ReadFile(resolved)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>
        <span class="cov8" title="1">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>
        <span class="cov8" title="1">config.setMermaidDefaults()
        config.setImageDefaults()
        if err := config.validateForSync(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid config: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;config, nil</span>
}

// LoadForListPages loads config with relaxed validation (space_key not required)
func LoadForListPages(path string) (*Config, error) <span class="cov8" title="1">{
        resolved := ResolveConfigPath(path)
        data, err := os.ReadFile(resolved)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>
        <span class="cov8" title="1">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>
        <span class="cov8" title="1">config.setMermaidDefaults()
        config.setImageDefaults()
        if err := config.validateForListPages(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid config: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;config, nil</span>
}

func (c *Config) validate() error <span class="cov8" title="1">{
        if c.Confluence.BaseURL == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("confluence.base_url is required")
        }</span>
        <span class="cov8" title="1">if c.Confluence.Username == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("confluence.username is required")
        }</span>
        <span class="cov8" title="1">if c.Confluence.APIToken == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("confluence.api_token is required")
        }</span>
        // Global space key optional when projects present
        <span class="cov8" title="1">if len(c.Projects) == 0 &amp;&amp; c.Confluence.SpaceKey == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("confluence.space_key is required (or define projects with their own space_key)")
        }</span>
        <span class="cov8" title="1">if err := c.validateProjects(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := c.validateMermaid(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := c.validateImages(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateForSync validates config for sync (space key can come from project or CLI)
func (c *Config) validateForSync() error <span class="cov8" title="1">{
        if c.Confluence.BaseURL == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("confluence.base_url is required")
        }</span>
        <span class="cov8" title="1">if c.Confluence.Username == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("confluence.username is required")
        }</span>
        <span class="cov8" title="1">if c.Confluence.APIToken == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("confluence.api_token is required")
        }</span>
        <span class="cov8" title="1">if err := c.validateProjects(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := c.validateMermaid(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := c.validateImages(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateForListPages validates config for list-pages (space key provided via flag or project)
func (c *Config) validateForListPages() error <span class="cov8" title="1">{
        if c.Confluence.BaseURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("confluence.base_url is required")
        }</span>
        <span class="cov8" title="1">if c.Confluence.Username == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("confluence.username is required")
        }</span>
        <span class="cov8" title="1">if c.Confluence.APIToken == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("confluence.api_token is required")
        }</span>
        <span class="cov8" title="1">if err := c.validateProjects(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := c.validateMermaid(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := c.validateImages(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateProjects validates multi-project configuration if present
func (c *Config) validateProjects() error <span class="cov8" title="1">{
        if len(c.Projects) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">seen := make(map[string]bool)
        for i, p := range c.Projects </span><span class="cov8" title="1">{
                if p.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("projects[%d].name is required", i)
                }</span>
                <span class="cov8" title="1">if seen[p.Name] </span><span class="cov8" title="1">{
                        return fmt.Errorf("duplicate project name '%s'", p.Name)
                }</span>
                <span class="cov8" title="1">seen[p.Name] = true
                if p.SpaceKey == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("projects[%d].space_key is required", i)
                }</span>
                <span class="cov8" title="1">if p.Local.MarkdownDir == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("projects[%d].local.markdown_dir is required", i)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SelectProject applies project-specific overrides (space key + local) based on name
func (c *Config) SelectProject(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("project name cannot be empty")
        }</span>
        <span class="cov8" title="1">for _, p := range c.Projects </span><span class="cov8" title="1">{
                if p.Name == name </span><span class="cov8" title="1">{
                        c.Confluence.SpaceKey = p.SpaceKey
                        c.Local = p.Local
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("project '%s' not found", name)</span>
}

// ApplyDefaultProject selects the first project if any. Returns true if applied.
func (c *Config) ApplyDefaultProject() bool <span class="cov8" title="1">{
        if len(c.Projects) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">first := c.Projects[0]
        c.Confluence.SpaceKey = first.SpaceKey
        c.Local = first.Local
        return true</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package confluence

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "net/url"
        "os"
        "path/filepath"
        "strings"

        "conflux/pkg/logger"
)

// PageUpdateForbiddenError indicates a page exists but cannot be updated (likely archived)
type PageUpdateForbiddenError struct {
        PageID string
        Title  string
        Msg    string
}

func (e *PageUpdateForbiddenError) Error() string <span class="cov8" title="1">{
        return e.Msg
}</span>

// IsPageUpdateForbidden checks if an error is a PageUpdateForbiddenError
func IsPageUpdateForbidden(err error) bool <span class="cov8" title="1">{
        var forbiddenErr *PageUpdateForbiddenError
        return errors.As(err, &amp;forbiddenErr)
}</span>

type Client struct {
        baseURL  string
        username string
        apiToken string
        client   *http.Client
        logger   *logger.Logger
}

type Page struct {
        ID    string `json:"id,omitempty"`
        Title string `json:"title"`
        Body  struct {
                Storage struct {
                        Value string `json:"value"`
                } `json:"storage"`
                View struct {
                        Value string `json:"value"`
                } `json:"view"`
        } `json:"body,omitempty"`
        Space struct {
                Key string `json:"key"`
        } `json:"space,omitempty"`
        Version struct {
                Number int `json:"number"`
        } `json:"version,omitempty"`
}

type PageInfo struct {
        ID       string     `json:"id"`
        Title    string     `json:"title"`
        Children []PageInfo `json:"children,omitempty"`
}

type Attachment struct {
        ID        string `json:"id"`
        Title     string `json:"title"`
        MediaType string `json:"mediaType"`
        Download  string `json:"downloadLink"`
        Links     struct {
                Download string `json:"download"`
        } `json:"_links"`
}

func New(baseURL, username, apiToken string) *Client <span class="cov8" title="1">{
        return &amp;Client{
                baseURL:  baseURL,
                username: username,
                apiToken: apiToken,
                client:   &amp;http.Client{},
        }
}</span>

func NewClient(baseURL, username, apiToken string, log *logger.Logger) *Client <span class="cov8" title="1">{
        return &amp;Client{
                baseURL:  baseURL,
                username: username,
                apiToken: apiToken,
                client:   &amp;http.Client{},
                logger:   log,
        }
}</span>

func (c *Client) CreatePage(spaceKey, title, content string) (*Page, error) <span class="cov8" title="1">{
        page := map[string]interface{}{
                "type":  "page",
                "title": title,
                "space": map[string]string{"key": spaceKey},
                "body": map[string]interface{}{
                        "storage": map[string]interface{}{
                                "value":          content,
                                "representation": "storage",
                        },
                },
        }

        data, err := json.Marshal(page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal page data: %w", err)
        }</span>

        // Debug: Log directory pages with children macro content
        <span class="cov8" title="1">if c.logger != nil &amp;&amp; len(content) &gt; 0 &amp;&amp; (containsChildrenMacro(content) || containsDirectoryKeywords(content)) </span><span class="cov0" title="0">{
                c.logger.Debug("Creating directory page '%s' with children macro content", title)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("POST", c.baseURL+"/rest/api/content", bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.SetBasicAuth(c.username, c.apiToken)
        req.Header.Set("Content-Type", "application/json")

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, body)
        }</span>

        <span class="cov8" title="1">var result Page
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

func (c *Client) CreatePageWithParent(spaceKey, title, content, parentID string) (*Page, error) <span class="cov8" title="1">{
        page := map[string]interface{}{
                "type":  "page",
                "title": title,
                "space": map[string]string{"key": spaceKey},
                "body": map[string]interface{}{
                        "storage": map[string]interface{}{
                                "value":          content,
                                "representation": "storage",
                        },
                },
        }

        // Add parent relationship if parentID is provided
        if parentID != "" </span><span class="cov8" title="1">{
                page["ancestors"] = []map[string]string{
                        {"id": parentID},
                }
        }</span>

        <span class="cov8" title="1">data, err := json.Marshal(page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal page data: %w", err)
        }</span>

        // Debug: Log directory pages with children macro content
        <span class="cov8" title="1">if c.logger != nil &amp;&amp; len(content) &gt; 0 &amp;&amp; (containsChildrenMacro(content) || containsDirectoryKeywords(content)) </span><span class="cov0" title="0">{
                c.logger.Debug("Creating directory page '%s' with parent '%s' and children macro content", title, parentID)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("POST", c.baseURL+"/rest/api/content", bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.SetBasicAuth(c.username, c.apiToken)
        req.Header.Set("Content-Type", "application/json")

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, body)
        }</span>

        <span class="cov8" title="1">var result Page
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

func (c *Client) UpdatePage(pageID, title, content string) (*Page, error) <span class="cov8" title="1">{
        // Debug: Log directory page updates
        if c.logger != nil &amp;&amp; len(content) &gt; 0 &amp;&amp; (containsChildrenMacro(content) || containsDirectoryKeywords(content)) </span><span class="cov0" title="0">{
                c.logger.Debug("Updating directory page '%s' with children macro content", title)
        }</span>

        // First, get the current page to retrieve its version
        <span class="cov8" title="1">currentPage, err := c.GetPage(pageID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get current page version: %w", err)
        }</span>

        // Increment the version number
        <span class="cov8" title="1">newVersion := currentPage.Version.Number + 1

        page := map[string]interface{}{
                "id":    pageID,
                "type":  "page",
                "title": title,
                "body": map[string]interface{}{
                        "storage": map[string]interface{}{
                                "value":          content,
                                "representation": "storage",
                        },
                },
                "version": map[string]interface{}{
                        "number": newVersion,
                },
        }

        data, err := json.Marshal(page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal page data: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("PUT", c.baseURL+"/rest/api/content/"+pageID, bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.SetBasicAuth(c.username, c.apiToken)
        req.Header.Set("Content-Type", "application/json")

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                if resp.StatusCode == http.StatusForbidden </span><span class="cov8" title="1">{
                        return nil, &amp;PageUpdateForbiddenError{
                                PageID: pageID,
                                Title:  title,
                                Msg:    fmt.Sprintf("API request failed with status %d: %s", resp.StatusCode, body),
                        }
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, body)</span>
        }

        <span class="cov8" title="1">var result Page
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

func (c *Client) GetPage(pageID string) (*Page, error) <span class="cov8" title="1">{
        req, err := http.NewRequest("GET", c.baseURL+"/rest/api/content/"+pageID+"?expand=version,body.storage,body.view", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.SetBasicAuth(c.username, c.apiToken)

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, body)
        }</span>

        <span class="cov8" title="1">var result Page
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

func (c *Client) FindPageByTitle(spaceKey, title string) (*Page, error) <span class="cov8" title="1">{
        params := url.Values{}
        params.Add("spaceKey", spaceKey)
        params.Add("title", title)
        params.Add("expand", "body.storage")

        req, err := http.NewRequest("GET", c.baseURL+"/rest/api/content?"+params.Encode(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.SetBasicAuth(c.username, c.apiToken)

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API request failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">var result struct {
                Results []Page `json:"results"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">if len(result.Results) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return &amp;result.Results[0], nil</span>
}

func (c *Client) GetPageHierarchy(spaceKey, parentPageTitle string) ([]PageInfo, error) <span class="cov8" title="1">{
        var pages []PageInfo
        var err error

        if parentPageTitle != "" </span><span class="cov8" title="1">{
                // Find the parent page first
                var parentPage *Page
                parentPage, err = c.FindPageByTitle(spaceKey, parentPageTitle)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to find parent page '%s': %w", parentPageTitle, err)
                }</span>
                <span class="cov8" title="1">if parentPage == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parent page '%s' not found in space '%s'", parentPageTitle, spaceKey)
                }</span>

                // Get children of the parent page
                <span class="cov8" title="1">pages, err = c.getChildPages(parentPage.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get child pages: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // Get all pages in the space
                pages, err = c.getAllPagesInSpace(spaceKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get pages in space: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return pages, nil</span>
}

func (c *Client) getAllPagesInSpace(spaceKey string) ([]PageInfo, error) <span class="cov8" title="1">{
        // Get all pages and build proper hierarchy
        allPages, err := c.getAllPagesWithParents(spaceKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Build the tree by finding root pages and their children
        <span class="cov8" title="1">return c.buildPageTree(allPages), nil</span>
}

// getAllPagesWithParents gets all pages in a space with parent information
func (c *Client) getAllPagesWithParents(spaceKey string) (map[string]PageInfo, error) <span class="cov8" title="1">{
        params := url.Values{}
        params.Add("spaceKey", spaceKey)
        params.Add("type", "page")
        params.Add("limit", "1000")
        params.Add("expand", "ancestors")

        req, err := http.NewRequest("GET", c.baseURL+"/rest/api/content?"+params.Encode(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.SetBasicAuth(c.username, c.apiToken)

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, body)
        }</span>

        <span class="cov8" title="1">var result struct {
                Results []struct {
                        ID        string `json:"id"`
                        Title     string `json:"title"`
                        Ancestors []struct {
                                ID    string `json:"id"`
                                Title string `json:"title"`
                        } `json:"ancestors"`
                } `json:"results"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">pages := make(map[string]PageInfo)
        parentChildMap := make(map[string][]string) // parentID -&gt; []childID

        for _, page := range result.Results </span><span class="cov8" title="1">{
                pageInfo := PageInfo{
                        ID:       page.ID,
                        Title:    page.Title,
                        Children: []PageInfo{}, // Initialize empty, will be populated later
                }
                pages[page.ID] = pageInfo

                // Determine parent-child relationships
                var parentID string
                if len(page.Ancestors) &gt; 0 </span><span class="cov8" title="1">{
                        // The immediate parent is the last ancestor
                        parentID = page.Ancestors[len(page.Ancestors)-1].ID
                }</span>

                <span class="cov8" title="1">if parentID != "" </span><span class="cov8" title="1">{
                        parentChildMap[parentID] = append(parentChildMap[parentID], page.ID)
                }</span>
        }

        // Now build the children relationships
        <span class="cov8" title="1">for parentID, childIDs := range parentChildMap </span><span class="cov8" title="1">{
                if parent, exists := pages[parentID]; exists </span><span class="cov8" title="1">{
                        for _, childID := range childIDs </span><span class="cov8" title="1">{
                                if child, exists := pages[childID]; exists </span><span class="cov8" title="1">{
                                        parent.Children = append(parent.Children, child)
                                }</span>
                        }
                        <span class="cov8" title="1">pages[parentID] = parent</span>
                }
        }

        <span class="cov8" title="1">return pages, nil</span>
}

// buildPageTree builds the tree structure by identifying root pages
func (c *Client) buildPageTree(allPages map[string]PageInfo) []PageInfo <span class="cov8" title="1">{
        // First pass: identify all pages that are children of other pages
        childPages := make(map[string]bool)
        for _, page := range allPages </span><span class="cov8" title="1">{
                for _, child := range page.Children </span><span class="cov8" title="1">{
                        childPages[child.ID] = true
                }</span>
        }

        // Second pass: root pages are those that are not children of any other page
        <span class="cov8" title="1">var rootPages []PageInfo
        for _, page := range allPages </span><span class="cov8" title="1">{
                if !childPages[page.ID] </span><span class="cov8" title="1">{
                        rootPages = append(rootPages, page)
                }</span>
        }

        <span class="cov8" title="1">return rootPages</span>
}

func (c *Client) getChildPages(pageID string) ([]PageInfo, error) <span class="cov8" title="1">{
        params := url.Values{}
        params.Add("expand", "children.page")

        req, err := http.NewRequest("GET", c.baseURL+"/rest/api/content/"+pageID+"/child/page?"+params.Encode(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.SetBasicAuth(c.username, c.apiToken)

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, body)
        }</span>

        <span class="cov8" title="1">var result struct {
                Results []PageInfo `json:"results"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        // Recursively get children for each page
        <span class="cov8" title="1">for i := range result.Results </span><span class="cov8" title="1">{
                children, err := c.getChildPages(result.Results[i].ID)
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Info("Warning: failed to get children for page '%s': %v", result.Results[i].Title, err)
                        continue</span>
                }
                <span class="cov8" title="1">result.Results[i].Children = children</span>
        }

        <span class="cov8" title="1">return result.Results, nil</span>
}

func (c *Client) UploadAttachment(pageID, filePath string) (*Attachment, error) <span class="cov8" title="1">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Create multipart form
        body := &amp;bytes.Buffer{}
        writer := multipart.NewWriter(body)

        // Add file field
        filename := filepath.Base(filePath)
        part, err := writer.CreateFormFile("file", filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create form file: %w", err)
        }</span>

        <span class="cov8" title="1">if _, copyErr := io.Copy(part, file); copyErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to copy file content: %w", copyErr)
        }</span>

        // Close the multipart writer
        <span class="cov8" title="1">if closeErr := writer.Close(); closeErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to close multipart writer: %w", closeErr)
        }</span>

        // Create request
        <span class="cov8" title="1">req, err := http.NewRequest("POST", c.baseURL+"/rest/api/content/"+pageID+"/child/attachment", body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.SetBasicAuth(c.username, c.apiToken)
        req.Header.Set("Content-Type", writer.FormDataContentType())
        req.Header.Set("X-Atlassian-Token", "no-check")

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                // Check if this is a duplicate filename error
                if resp.StatusCode == http.StatusBadRequest &amp;&amp; strings.Contains(string(body), "same file name as an existing attachment") </span><span class="cov8" title="1">{
                        // Try to find the existing attachment with this filename
                        attachment, findErr := c.findAttachmentByFilename(pageID, filename)
                        if findErr == nil &amp;&amp; attachment != nil </span><span class="cov8" title="1">{
                                if c.logger != nil </span><span class="cov8" title="1">{
                                        c.logger.Debug("Found existing attachment '%s' for page ID '%s'", filename, pageID)
                                }</span>
                                <span class="cov8" title="1">return attachment, nil</span>
                        }
                        // If finding the attachment fails, we still return the original error
                        <span class="cov0" title="0">return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, body)</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, body)</span>
        }

        <span class="cov8" title="1">var result struct {
                Results []Attachment `json:"results"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">if len(result.Results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no attachment returned in response")
        }</span>

        <span class="cov8" title="1">if c.logger != nil </span><span class="cov8" title="1">{
                c.logger.Debug("Uploaded attachment '%s' to page ID '%s'", filename, pageID)
        }</span>

        <span class="cov8" title="1">return &amp;result.Results[0], nil</span>
}

// ListAttachments returns all attachments for a page
func (c *Client) ListAttachments(pageID string) ([]Attachment, error) <span class="cov8" title="1">{
        // v2 API endpoint
        req, err := http.NewRequest("GET", c.baseURL+"/api/v2/pages/"+pageID+"/attachments", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.SetBasicAuth(c.username, c.apiToken)
        req.Header.Set("Accept", "application/json")

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, body)
        }</span>

        <span class="cov8" title="1">var result struct {
                Results []Attachment `json:"results"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>
        <span class="cov8" title="1">return result.Results, nil</span>
}

// findAttachmentByFilename looks for an existing attachment with the given filename on a page
func (c *Client) findAttachmentByFilename(pageID, filename string) (*Attachment, error) <span class="cov8" title="1">{
        req, err := http.NewRequest("GET", c.baseURL+"/rest/api/content/"+pageID+"/child/attachment", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.SetBasicAuth(c.username, c.apiToken)

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, body)
        }</span>

        <span class="cov8" title="1">var result struct {
                Results []Attachment `json:"results"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        // Look for attachment with matching filename
        <span class="cov8" title="1">for _, attachment := range result.Results </span><span class="cov8" title="1">{
                if attachment.Title == filename </span><span class="cov8" title="1">{
                        return &amp;attachment, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("attachment with filename '%s' not found", filename)</span>
}

func (c *Client) GetAttachmentDownloadURL(pageID, attachmentID string) (string, error) <span class="cov8" title="1">{
        attachments, err := c.ListAttachments(pageID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">for _, att := range attachments </span><span class="cov8" title="1">{
                if att.ID == attachmentID </span><span class="cov8" title="1">{
                        if att.Links.Download != "" </span><span class="cov8" title="1">{
                                return c.baseURL + att.Links.Download, nil
                        }</span>
                        <span class="cov0" title="0">if att.Download != "" </span><span class="cov0" title="0">{
                                return c.baseURL + att.Download, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return "", fmt.Errorf("attachment %s not found for page %s", attachmentID, pageID)</span>
}

// DoAuthenticatedRequest performs an HTTP request with Confluence authentication
func (c *Client) DoAuthenticatedRequest(req *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        req.SetBasicAuth(c.username, c.apiToken)
        return c.client.Do(req)
}</span>

// Helper functions for debug logging
func containsChildrenMacro(content string) bool <span class="cov8" title="1">{
        return strings.Contains(content, "ac:structured-macro ac:name=\"children\"") ||
                strings.Contains(content, "ac:structured-macro ac:name='children'") ||
                strings.Contains(content, "children")
}</span>

func containsDirectoryKeywords(content string) bool <span class="cov8" title="1">{
        content = strings.ToLower(content)
        return strings.Contains(content, "directory page") ||
                strings.Contains(content, "automatically created to organize") ||
                strings.Contains(content, "automatically created") ||
                strings.Contains(content, "documentation for") ||
                strings.Contains(content, "directory") ||
                strings.Contains(content, "organize")
}</span>

// GetChildPages returns all child pages of a given page
func (c *Client) GetChildPages(pageID string) ([]PageInfo, error) <span class="cov8" title="1">{
        return c.getChildPages(pageID)
}</span>

// GetPageAncestors returns the ancestor chain for a page
func (c *Client) GetPageAncestors(pageID string) ([]PageInfo, error) <span class="cov8" title="1">{
        params := url.Values{}
        params.Add("expand", "ancestors")

        req, err := http.NewRequest("GET", c.baseURL+"/rest/api/content/"+pageID+"?"+params.Encode(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.SetBasicAuth(c.username, c.apiToken)

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, body)
        }</span>

        <span class="cov8" title="1">var result struct {
                Ancestors []PageInfo `json:"ancestors"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">return result.Ancestors, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package confluence

// MockClient is an in-memory implementation of ConfluenceClient for tests.
type MockClient struct {
        Pages            map[string]*Page        // pageID -&gt; Page
        PagesByTitle     map[string]*Page        // spaceKey:title -&gt; Page
        Children         map[string][]PageInfo   // pageID -&gt; children
        Ancestors        map[string][]PageInfo   // pageID -&gt; ancestors chain
        SpaceHierarchies map[string][]PageInfo   // spaceKey -&gt; root pages (fully nested)
        Attachments      map[string][]Attachment // pageID -&gt; attachments
        CreateCalls      []string                // titles created (for assertions)
        UpdateCalls      []string                // titles updated
        LastUploadedFile string
        FailFindByTitle  bool
}

func NewMockClient() *MockClient <span class="cov0" title="0">{
        return &amp;MockClient{
                Pages:            make(map[string]*Page),
                PagesByTitle:     make(map[string]*Page),
                Children:         make(map[string][]PageInfo),
                Ancestors:        make(map[string][]PageInfo),
                SpaceHierarchies: make(map[string][]PageInfo),
                Attachments:      make(map[string][]Attachment),
        }
}</span>

func (m *MockClient) key(spaceKey, title string) string <span class="cov0" title="0">{ return spaceKey + ":" + title }</span>

func (m *MockClient) CreatePage(spaceKey, title, content string) (*Page, error) <span class="cov0" title="0">{
        p := &amp;Page{ID: title + "-id", Title: title}
        p.Body.Storage.Value = content
        m.Pages[p.ID] = p
        m.PagesByTitle[m.key(spaceKey, title)] = p
        m.CreateCalls = append(m.CreateCalls, title)
        return p, nil
}</span>

func (m *MockClient) CreatePageWithParent(spaceKey, title, content, parentID string) (*Page, error) <span class="cov0" title="0">{
        return m.CreatePage(spaceKey, title, content)
}</span>

func (m *MockClient) UpdatePage(pageID, title, content string) (*Page, error) <span class="cov0" title="0">{
        if p, ok := m.Pages[pageID]; ok </span><span class="cov0" title="0">{
                p.Title = title
                p.Body.Storage.Value = content
                m.UpdateCalls = append(m.UpdateCalls, title)
                return p, nil
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func (m *MockClient) FindPageByTitle(spaceKey, title string) (*Page, error) <span class="cov0" title="0">{
        if m.FailFindByTitle </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return m.PagesByTitle[m.key(spaceKey, title)], nil</span>
}

func (m *MockClient) GetPage(pageID string) (*Page, error) <span class="cov0" title="0">{
        return m.Pages[pageID], nil
}</span>

func (m *MockClient) UploadAttachment(pageID, filePath string) (*Attachment, error) <span class="cov0" title="0">{
        att := Attachment{ID: "att-" + filePath, Title: filePath}
        m.Attachments[pageID] = append(m.Attachments[pageID], att)
        m.LastUploadedFile = filePath
        return &amp;att, nil
}</span>

func (m *MockClient) GetPageHierarchy(spaceKey, parentPageTitle string) ([]PageInfo, error) <span class="cov0" title="0">{
        if parentPageTitle != "" </span><span class="cov0" title="0">{
                // find parent in hierarchy and return its children if available
                roots := m.SpaceHierarchies[spaceKey]
                var stack []PageInfo
                stack = append(stack, roots...)
                for len(stack) &gt; 0 </span><span class="cov0" title="0">{
                        cur := stack[len(stack)-1]
                        stack = stack[:len(stack)-1]
                        if cur.Title == parentPageTitle </span><span class="cov0" title="0">{
                                return cur.Children, nil
                        }</span>
                        <span class="cov0" title="0">stack = append(stack, cur.Children...)</span>
                }
                <span class="cov0" title="0">return []PageInfo{}, nil</span>
        }
        <span class="cov0" title="0">return m.SpaceHierarchies[spaceKey], nil</span>
}

func (m *MockClient) GetPageAncestors(pageID string) ([]PageInfo, error) <span class="cov0" title="0">{
        return m.Ancestors[pageID], nil
}</span>

func (m *MockClient) GetChildPages(pageID string) ([]PageInfo, error) <span class="cov0" title="0">{
        return m.Children[pageID], nil
}</span>

func (m *MockClient) ListAttachments(pageID string) ([]Attachment, error) <span class="cov0" title="0">{
        return m.Attachments[pageID], nil
}</span>

func (m *MockClient) GetAttachmentDownloadURL(pageID, attachmentID string) (string, error) <span class="cov0" title="0">{
        // Return a dummy local path for testing
        return "attachments/" + attachmentID, nil
}</span>

var _ ConfluenceClient = (*MockClient)(nil)
</pre>
		
		<pre class="file" id="file12" style="display: none">package images

import (
        "crypto/sha256"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "conflux/internal/config"
        "conflux/pkg/logger"
)

// ImageReference represents an image found in markdown content
type ImageReference struct {
        MarkdownSyntax string // Original markdown: ![alt text](image.png)
        AltText        string // Alt text from the markdown
        FilePath       string // Path to the image file (relative or absolute)
        AbsolutePath   string // Resolved absolute path to the image file
}

// Processor handles image processing and validation
type Processor struct {
        config *config.ImageConfig
        logger *logger.Logger
}

// NewProcessor creates a new image processor
func NewProcessor(cfg *config.ImageConfig, log *logger.Logger) *Processor <span class="cov8" title="1">{
        return &amp;Processor{
                config: cfg,
                logger: log,
        }
}</span>

// FindImageReferences searches markdown content for image references ![alt](path)
func (p *Processor) FindImageReferences(markdown string, markdownDir string) ([]*ImageReference, error) <span class="cov8" title="1">{
        // Regex to match ![alt text](image.png) or ![alt text](./images/file.png)
        imageRegex := regexp.MustCompile(`!\[([^\]]*)\]\(([^)]+)\)`)
        matches := imageRegex.FindAllStringSubmatch(markdown, -1)

        var references []*ImageReference

        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) != 3 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">ref := &amp;ImageReference{
                        MarkdownSyntax: match[0], // Full match: ![alt](path)
                        AltText:        match[1], // Alt text
                        FilePath:       match[2], // File path
                }

                // Resolve absolute path
                var err error
                if filepath.IsAbs(ref.FilePath) </span><span class="cov8" title="1">{
                        ref.AbsolutePath = ref.FilePath
                }</span> else<span class="cov8" title="1"> {
                        // Relative path - resolve relative to the markdown file's directory
                        ref.AbsolutePath, err = filepath.Abs(filepath.Join(markdownDir, ref.FilePath))
                        if err != nil </span><span class="cov0" title="0">{
                                if p.logger != nil </span><span class="cov0" title="0">{
                                        p.logger.Debug("Failed to resolve absolute path for image '%s': %v", ref.FilePath, err)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                }

                <span class="cov8" title="1">references = append(references, ref)</span>
        }

        <span class="cov8" title="1">return references, nil</span>
}

// ValidateImageFile checks if an image file exists and is supported
func (p *Processor) ValidateImageFile(ref *ImageReference) error <span class="cov8" title="1">{
        // Check if file exists
        info, err := os.Stat(ref.AbsolutePath)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return fmt.Errorf("image file not found: %s", ref.AbsolutePath)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to access image file %s: %w", ref.AbsolutePath, err)</span>
        }

        // Check if it's a regular file
        <span class="cov8" title="1">if !info.Mode().IsRegular() </span><span class="cov0" title="0">{
                return fmt.Errorf("image path is not a regular file: %s", ref.AbsolutePath)
        }</span>

        // Check file size
        <span class="cov8" title="1">if p.config.MaxFileSize &gt; 0 &amp;&amp; info.Size() &gt; p.config.MaxFileSize </span><span class="cov8" title="1">{
                return fmt.Errorf("image file %s exceeds maximum size limit (%d bytes): %d bytes", 
                        ref.AbsolutePath, p.config.MaxFileSize, info.Size())
        }</span>

        // Check file extension
        <span class="cov8" title="1">ext := strings.ToLower(strings.TrimPrefix(filepath.Ext(ref.AbsolutePath), "."))
        if !p.isFormatSupported(ext) </span><span class="cov8" title="1">{
                return fmt.Errorf("image format '%s' is not supported for file %s. Supported formats: %v", 
                        ext, ref.AbsolutePath, p.config.SupportedFormats)
        }</span>

        <span class="cov8" title="1">if p.logger != nil </span><span class="cov0" title="0">{
                p.logger.Debug("Validated image file '%s' (%d bytes, format: %s)", ref.AbsolutePath, info.Size(), ext)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateImageReferences validates all image references found in markdown
func (p *Processor) ValidateImageReferences(references []*ImageReference) ([]*ImageReference, error) <span class="cov0" title="0">{
        var validRefs []*ImageReference
        var errors []string

        for _, ref := range references </span><span class="cov0" title="0">{
                if err := p.ValidateImageFile(ref); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, err.Error())
                        if p.logger != nil </span><span class="cov0" title="0">{
                                p.logger.Debug("Skipping invalid image reference: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">validRefs = append(validRefs, ref)</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                if p.logger != nil </span><span class="cov0" title="0">{
                        p.logger.Debug("Found %d invalid image references out of %d total", len(errors), len(references))
                }</span>
                // For now, just log errors but continue with valid references
                // In the future, we might want to make this configurable (fail vs warn)
        }

        <span class="cov0" title="0">return validRefs, nil</span>
}

// isFormatSupported checks if the given file extension is in the supported formats list
func (p *Processor) isFormatSupported(ext string) bool <span class="cov8" title="1">{
        for _, format := range p.config.SupportedFormats </span><span class="cov8" title="1">{
                if strings.ToLower(format) == ext </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// GetImageFilename returns the filename portion of an image path for use in Confluence attachments
func GetImageFilename(imagePath string) string <span class="cov8" title="1">{
        return filepath.Base(imagePath)
}</span>

// CalculateImageHash calculates the SHA256 hash of an image file
func CalculateImageHash(imagePath string) (string, error) <span class="cov0" title="0">{
        file, err := os.Open(imagePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to open image file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        hash := sha256.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to calculate hash: %w", err)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%x", hash.Sum(nil)), nil</span>
}</pre>
		
		<pre class="file" id="file13" style="display: none">package markdown

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "conflux/internal/config"
        "conflux/internal/confluence"
        "conflux/internal/images"
        "conflux/internal/mermaid"
)

type Document struct {
        Title    string
        Content  string
        FilePath string
}

func ParseFile(filePath string) (*Document, error) <span class="cov8" title="1">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var lines []string
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                lines = append(lines, scanner.Text())
        }</span>

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov8" title="1">doc := &amp;Document{
                FilePath: filePath,
                Content:  strings.Join(lines, "\n"),
        }

        doc.Title = extractTitle(lines, filePath)

        return doc, nil</span>
}

func extractTitle(lines []string, filePath string) string <span class="cov8" title="1">{
        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if strings.HasPrefix(line, "# ") </span><span class="cov8" title="1">{
                        return strings.TrimSpace(line[2:])
                }</span>
        }

        <span class="cov8" title="1">base := filepath.Base(filePath)
        return strings.TrimSuffix(base, filepath.Ext(base))</span>
}

func FindMarkdownFiles(path string, exclude []string) ([]string, error) <span class="cov8" title="1">{
        var files []string

        // Check if the path is a single file
        info, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to access path %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                // Handle single file
                if strings.ToLower(filepath.Ext(path)) != ".md" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("file %s is not a markdown file (.md)", path)
                }</span>

                // Check if file matches any exclude pattern
                <span class="cov8" title="1">for _, pattern := range exclude </span><span class="cov8" title="1">{
                        if matched, _ := filepath.Match(pattern, filepath.Base(path)); matched </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("file %s matches exclude pattern %s", path, pattern)
                        }</span>
                }

                // Convert to absolute path
                <span class="cov8" title="1">var absPath string
                absPath, err = filepath.Abs(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get absolute path for %s: %w", path, err)
                }</span>

                <span class="cov8" title="1">return []string{absPath}, nil</span>
        }

        // Handle directory (original logic)
        <span class="cov8" title="1">err = filepath.Walk(path, func(walkPath string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">if strings.ToLower(filepath.Ext(walkPath)) != ".md" </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">for _, pattern := range exclude </span><span class="cov8" title="1">{
                        if matched, _ := filepath.Match(pattern, filepath.Base(walkPath)); matched </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                }

                <span class="cov8" title="1">files = append(files, walkPath)
                return nil</span>
        })

        <span class="cov8" title="1">return files, err</span>
}

func ConvertToConfluenceFormat(markdown string) string <span class="cov8" title="1">{
        return ConvertToConfluenceFormatWithMermaid(markdown, nil, nil, "")
}</span>

func ConvertToConfluenceFormatWithMermaid(markdown string, cfg *config.Config, client *confluence.Client, pageID string) string <span class="cov8" title="1">{
        lines := strings.Split(markdown, "\n")
        var result []string
        inCodeBlock := false
        inUnorderedList := false
        inOrderedList := false
        var codeBlockLang string
        var codeBlockContent []string

        for _, line := range lines </span><span class="cov8" title="1">{
                // Handle code blocks
                if strings.HasPrefix(strings.TrimSpace(line), "```") </span><span class="cov8" title="1">{
                        if !inCodeBlock </span><span class="cov8" title="1">{
                                // Starting code block
                                inCodeBlock = true
                                codeBlockLang = strings.TrimSpace(strings.TrimPrefix(strings.TrimSpace(line), "```"))
                                codeBlockContent = []string{} // Reset content
                        }</span> else<span class="cov8" title="1"> {
                                // Ending code block
                                inCodeBlock = false

                                // Process the code block based on language
                                if codeBlockLang == "mermaid" &amp;&amp; cfg != nil </span><span class="cov8" title="1">{
                                        processed := processMermaidDiagram(strings.Join(codeBlockContent, "\n"), cfg, client, pageID)
                                        if processed != "" </span><span class="cov8" title="1">{
                                                result = append(result, processed)
                                        }</span> else<span class="cov0" title="0"> {
                                                // Fallback to regular code block if processing failed
                                                result = append(result, fmt.Sprintf(`&lt;ac:structured-macro ac:name="code" ac:schema-version="1"&gt;&lt;ac:parameter ac:name="language"&gt;%s&lt;/ac:parameter&gt;&lt;ac:plain-text-body&gt;&lt;![CDATA[`, codeBlockLang))
                                                result = append(result, strings.Join(codeBlockContent, "\n"))
                                                result = append(result, `]]&gt;&lt;/ac:plain-text-body&gt;&lt;/ac:structured-macro&gt;`)
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        // Regular code block processing
                                        codeContent := strings.TrimSpace(strings.Join(codeBlockContent, "\n"))
                                        if codeBlockLang != "" </span><span class="cov8" title="1">{
                                                result = append(result, fmt.Sprintf(`&lt;ac:structured-macro ac:name="code" ac:schema-version="1"&gt;&lt;ac:parameter ac:name="language"&gt;%s&lt;/ac:parameter&gt;&lt;ac:plain-text-body&gt;&lt;![CDATA[%s]]&gt;&lt;/ac:plain-text-body&gt;&lt;/ac:structured-macro&gt;`, codeBlockLang, codeContent))
                                        }</span> else<span class="cov8" title="1"> {
                                                result = append(result, fmt.Sprintf(`&lt;ac:structured-macro ac:name="code" ac:schema-version="1"&gt;&lt;ac:plain-text-body&gt;&lt;![CDATA[%s]]&gt;&lt;/ac:plain-text-body&gt;&lt;/ac:structured-macro&gt;`, codeContent))
                                        }</span>
                                }

                                <span class="cov8" title="1">codeBlockLang = ""
                                codeBlockContent = []string{}</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">if inCodeBlock </span><span class="cov8" title="1">{
                        // Inside code block - collect content
                        codeBlockContent = append(codeBlockContent, line)
                        continue</span>
                }

                // Handle headers
                <span class="cov8" title="1">if strings.HasPrefix(line, "# ") </span><span class="cov8" title="1">{
                        closeOpenLists(&amp;result, &amp;inUnorderedList, &amp;inOrderedList)
                        title := strings.TrimSpace(line[2:])
                        result = append(result, fmt.Sprintf("&lt;h1&gt;%s&lt;/h1&gt;", escapeHTML(title)))
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(line, "## ") </span><span class="cov8" title="1">{
                        closeOpenLists(&amp;result, &amp;inUnorderedList, &amp;inOrderedList)
                        title := strings.TrimSpace(line[3:])
                        result = append(result, fmt.Sprintf("&lt;h2&gt;%s&lt;/h2&gt;", escapeHTML(title)))
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(line, "### ") </span><span class="cov8" title="1">{
                        closeOpenLists(&amp;result, &amp;inUnorderedList, &amp;inOrderedList)
                        title := strings.TrimSpace(line[4:])
                        result = append(result, fmt.Sprintf("&lt;h3&gt;%s&lt;/h3&gt;", escapeHTML(title)))
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(line, "#### ") </span><span class="cov8" title="1">{
                        closeOpenLists(&amp;result, &amp;inUnorderedList, &amp;inOrderedList)
                        title := strings.TrimSpace(line[5:])
                        result = append(result, fmt.Sprintf("&lt;h4&gt;%s&lt;/h4&gt;", escapeHTML(title)))
                        continue</span>
                }

                // Handle unordered lists
                <span class="cov8" title="1">if strings.HasPrefix(strings.TrimSpace(line), "- ") || strings.HasPrefix(strings.TrimSpace(line), "* ") </span><span class="cov8" title="1">{
                        if inOrderedList </span><span class="cov0" title="0">{
                                result = append(result, "&lt;/ol&gt;")
                                inOrderedList = false
                        }</span>
                        <span class="cov8" title="1">if !inUnorderedList </span><span class="cov8" title="1">{
                                result = append(result, "&lt;ul&gt;")
                                inUnorderedList = true
                        }</span>
                        <span class="cov8" title="1">content := strings.TrimSpace(line[strings.Index(line, strings.TrimSpace(line))+2:])
                        content = convertInlineFormatting(content)
                        result = append(result, fmt.Sprintf("&lt;li&gt;%s&lt;/li&gt;", content))
                        continue</span>
                }

                // Handle numbered lists
                <span class="cov8" title="1">if len(strings.TrimSpace(line)) &gt; 0 &amp;&amp; strings.Contains(strings.TrimSpace(line), ". ") </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(line)
                        if len(trimmed) &gt; 2 </span><span class="cov8" title="1">{
                                firstChar := trimmed[0]
                                if firstChar &gt;= '0' &amp;&amp; firstChar &lt;= '9' &amp;&amp; trimmed[1] == '.' &amp;&amp; trimmed[2] == ' ' </span><span class="cov8" title="1">{
                                        if inUnorderedList </span><span class="cov8" title="1">{
                                                result = append(result, "&lt;/ul&gt;")
                                                inUnorderedList = false
                                        }</span>
                                        <span class="cov8" title="1">if !inOrderedList </span><span class="cov8" title="1">{
                                                result = append(result, "&lt;ol&gt;")
                                                inOrderedList = true
                                        }</span>
                                        <span class="cov8" title="1">content := strings.TrimSpace(trimmed[3:])
                                        content = convertInlineFormatting(content)
                                        result = append(result, fmt.Sprintf("&lt;li&gt;%s&lt;/li&gt;", content))
                                        continue</span>
                                }
                        }
                }

                // Handle empty lines
                <span class="cov8" title="1">if strings.TrimSpace(line) == "" </span><span class="cov8" title="1">{
                        closeOpenLists(&amp;result, &amp;inUnorderedList, &amp;inOrderedList)
                        result = append(result, "&lt;p/&gt;")
                        continue</span>
                }

                // Regular paragraph
                <span class="cov8" title="1">closeOpenLists(&amp;result, &amp;inUnorderedList, &amp;inOrderedList)
                content := convertInlineFormatting(line)
                result = append(result, fmt.Sprintf("&lt;p&gt;%s&lt;/p&gt;", content))</span>
        }

        // Close any remaining lists
        <span class="cov8" title="1">closeOpenLists(&amp;result, &amp;inUnorderedList, &amp;inOrderedList)

        return strings.Join(result, "\n")</span>
}

func closeOpenLists(result *[]string, inUnorderedList *bool, inOrderedList *bool) <span class="cov8" title="1">{
        if *inUnorderedList </span><span class="cov8" title="1">{
                *result = append(*result, "&lt;/ul&gt;")
                *inUnorderedList = false
        }</span>
        <span class="cov8" title="1">if *inOrderedList </span><span class="cov8" title="1">{
                *result = append(*result, "&lt;/ol&gt;")
                *inOrderedList = false
        }</span>
}

func convertInlineFormatting(text string) string <span class="cov8" title="1">{
        // First escape HTML in the entire text
        text = escapeHTML(text)
        // Handle bold (**text** or __text__)
        text = convertBoldFromEscaped(text)
        // Handle italic (*text* or _text_)
        text = convertItalicFromEscaped(text)
        // Handle inline code
        text = convertInlineCodeFromEscaped(text)
        return text
}</span>

func convertBoldFromEscaped(text string) string <span class="cov8" title="1">{
        // Handle **bold** - back to simple approach (text already escaped)
        result := text

        for strings.Contains(result, "**") </span><span class="cov8" title="1">{
                firstIndex := strings.Index(result, "**")
                if firstIndex == -1 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Find the next ** after the first one
                <span class="cov8" title="1">secondIndex := strings.Index(result[firstIndex+2:], "**")
                if secondIndex == -1 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">secondIndex += firstIndex + 2

                before := result[:firstIndex]
                boldContent := result[firstIndex+2 : secondIndex]
                after := result[secondIndex+2:]

                result = before + "&lt;strong&gt;" + boldContent + "&lt;/strong&gt;" + after</span>
        }
        <span class="cov8" title="1">return result</span>
}

func convertItalicFromEscaped(text string) string <span class="cov8" title="1">{
        // Handle *italic* (but not ** which is bold) - working with escaped text
        i := 0
        for i &lt; len(text) </span><span class="cov8" title="1">{
                if text[i] == '*' &amp;&amp; (i == 0 || text[i-1] != '*') &amp;&amp; (i+1 &lt; len(text) &amp;&amp; text[i+1] != '*') </span><span class="cov8" title="1">{
                        // Found single asterisk
                        nextIndex := -1
                        for j := i + 1; j &lt; len(text); j++ </span><span class="cov8" title="1">{
                                if text[j] == '*' &amp;&amp; (j+1 &gt;= len(text) || text[j+1] != '*') </span><span class="cov8" title="1">{
                                        nextIndex = j
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if nextIndex != -1 </span><span class="cov8" title="1">{
                                before := text[:i]
                                italicText := text[i+1 : nextIndex]
                                after := text[nextIndex+1:]
                                text = before + "&lt;em&gt;" + italicText + "&lt;/em&gt;" + after
                                i = len(before) + len("&lt;em&gt;") + len(italicText) + len("&lt;/em&gt;")
                                continue</span>
                        }
                }
                <span class="cov8" title="1">i++</span>
        }
        <span class="cov8" title="1">return text</span>
}

func convertInlineCodeFromEscaped(text string) string <span class="cov8" title="1">{
        // Handle `inline code` - working with escaped text
        for strings.Contains(text, "`") </span><span class="cov8" title="1">{
                firstIndex := strings.Index(text, "`")
                if firstIndex == -1 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">secondIndex := strings.Index(text[firstIndex+1:], "`")
                if secondIndex == -1 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">secondIndex += firstIndex + 1

                before := text[:firstIndex]
                codeText := text[firstIndex+1 : secondIndex]
                after := text[secondIndex+1:]
                text = before + "&lt;code&gt;" + codeText + "&lt;/code&gt;" + after</span>
        }
        <span class="cov8" title="1">return text</span>
}

func convertBold(text string) string <span class="cov8" title="1">{
        result := text

        for </span><span class="cov8" title="1">{
                // Skip any ** that are inside existing &lt;strong&gt; tags to prevent recursive processing
                firstIndex := -1
                for i := 0; i &lt; len(result)-1; i++ </span><span class="cov8" title="1">{
                        if result[i:i+2] == "**" </span><span class="cov8" title="1">{
                                // Check if this ** is inside a &lt;strong&gt; tag
                                beforeThis := result[:i]
                                strongOpen := strings.LastIndex(beforeThis, "&lt;strong&gt;")
                                strongClose := strings.LastIndex(beforeThis, "&lt;/strong&gt;")

                                // If the last &lt;strong&gt; is more recent than the last &lt;/strong&gt;, we're inside a tag
                                if strongOpen != -1 &amp;&amp; (strongClose == -1 || strongOpen &gt; strongClose) </span><span class="cov8" title="1">{
                                        continue</span> // Skip this **, it's inside a strong tag
                                }

                                <span class="cov8" title="1">firstIndex = i
                                break</span>
                        }
                }

                <span class="cov8" title="1">if firstIndex == -1 </span><span class="cov8" title="1">{
                        break</span>
                }

                // Find all ** positions after the first one
                <span class="cov8" title="1">remaining := result[firstIndex+2:]
                if !strings.Contains(remaining, "**") </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">positions := []int{}
                searchPos := 0
                for </span><span class="cov8" title="1">{
                        pos := strings.Index(remaining[searchPos:], "**")
                        if pos == -1 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">actualPos := firstIndex + 2 + searchPos + pos

                        // Check if this position is inside a strong tag
                        beforeThis := result[:actualPos]
                        strongOpen := strings.LastIndex(beforeThis, "&lt;strong&gt;")
                        strongClose := strings.LastIndex(beforeThis, "&lt;/strong&gt;")

                        if strongOpen != -1 &amp;&amp; (strongClose == -1 || strongOpen &gt; strongClose) </span><span class="cov0" title="0">{
                                searchPos += pos + 2
                                continue</span> // Skip this **, it's inside a strong tag
                        }

                        <span class="cov8" title="1">positions = append(positions, actualPos)
                        searchPos += pos + 2</span>
                }

                <span class="cov8" title="1">if len(positions) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">var secondIndex int

                if len(positions) == 1 </span><span class="cov8" title="1">{
                        // Simple case - only one closing **
                        secondIndex = positions[0]
                }</span> else<span class="cov8" title="1"> if len(positions) == 3 </span><span class="cov8" title="1">{
                        // Check pattern for nested vs separate
                        firstClose := positions[0]
                        secondOpen := positions[1]
                        lastClose := positions[2]

                        betweenSections := result[firstClose+2 : secondOpen]

                        // Separate sections if there's meaningful content with spaces
                        if len(strings.TrimSpace(betweenSections)) &gt; 2 &amp;&amp; strings.Contains(betweenSections, " ") </span><span class="cov8" title="1">{
                                secondIndex = firstClose // **first** and **second**
                        }</span> else<span class="cov8" title="1"> {
                                secondIndex = lastClose // **nested **bold** text**
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Default to first closing
                        secondIndex = positions[0]
                }</span>

                <span class="cov8" title="1">before := result[:firstIndex]
                boldContent := result[firstIndex+2 : secondIndex]
                after := result[secondIndex+2:]

                result = before + "&lt;strong&gt;" + escapeHTML(boldContent) + "&lt;/strong&gt;" + after</span>
        }
        <span class="cov8" title="1">return result</span>
}

func convertItalic(text string) string <span class="cov8" title="1">{
        // Handle *italic* (but not ** which is bold)
        i := 0
        for i &lt; len(text) </span><span class="cov8" title="1">{
                if text[i] == '*' &amp;&amp; (i == 0 || text[i-1] != '*') &amp;&amp; (i+1 &lt; len(text) &amp;&amp; text[i+1] != '*') </span><span class="cov8" title="1">{
                        // Found single asterisk
                        nextIndex := -1
                        for j := i + 1; j &lt; len(text); j++ </span><span class="cov8" title="1">{
                                if text[j] == '*' &amp;&amp; (j+1 &gt;= len(text) || text[j+1] != '*') </span><span class="cov8" title="1">{
                                        nextIndex = j
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if nextIndex != -1 </span><span class="cov8" title="1">{
                                before := text[:i]
                                italicText := text[i+1 : nextIndex]
                                after := text[nextIndex+1:]
                                text = before + "&lt;em&gt;" + escapeHTML(italicText) + "&lt;/em&gt;" + after
                                i = len(before) + len("&lt;em&gt;") + len(italicText) + len("&lt;/em&gt;")
                                continue</span>
                        }
                }
                <span class="cov8" title="1">i++</span>
        }
        <span class="cov8" title="1">return text</span>
}

func convertInlineCode(text string) string <span class="cov8" title="1">{
        // Handle `inline code`
        for strings.Contains(text, "`") </span><span class="cov8" title="1">{
                firstIndex := strings.Index(text, "`")
                if firstIndex == -1 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">secondIndex := strings.Index(text[firstIndex+1:], "`")
                if secondIndex == -1 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">secondIndex += firstIndex + 1

                before := text[:firstIndex]
                codeText := text[firstIndex+1 : secondIndex]
                after := text[secondIndex+1:]
                text = before + "&lt;code&gt;" + escapeHTML(codeText) + "&lt;/code&gt;" + after</span>
        }
        <span class="cov8" title="1">return text</span>
}

func escapeHTML(text string) string <span class="cov8" title="1">{
        text = strings.ReplaceAll(text, "&amp;", "&amp;amp;")
        text = strings.ReplaceAll(text, "&lt;", "&amp;lt;")
        text = strings.ReplaceAll(text, "&gt;", "&amp;gt;")
        text = strings.ReplaceAll(text, "\"", "&amp;quot;")
        text = strings.ReplaceAll(text, "'", "&amp;#39;")
        return text
}</span>

func processMermaidDiagram(content string, cfg *config.Config, client *confluence.Client, pageID string) string <span class="cov8" title="1">{
        if cfg.Mermaid.Mode == "preserve" </span><span class="cov8" title="1">{
                // Return original mermaid code block
                return fmt.Sprintf(`&lt;ac:structured-macro ac:name="code" ac:schema-version="1"&gt;&lt;ac:parameter ac:name="language"&gt;mermaid&lt;/ac:parameter&gt;&lt;ac:plain-text-body&gt;&lt;![CDATA[%s]]&gt;&lt;/ac:plain-text-body&gt;&lt;/ac:structured-macro&gt;`, content)
        }</span>

        // Validate mermaid content
        <span class="cov0" title="0">if err := mermaid.ValidateContent(content); err != nil </span><span class="cov0" title="0">{
                // Return as regular code block if invalid
                return fmt.Sprintf(`&lt;ac:structured-macro ac:name="code" ac:schema-version="1"&gt;&lt;ac:parameter ac:name="language"&gt;mermaid&lt;/ac:parameter&gt;&lt;ac:plain-text-body&gt;&lt;![CDATA[%s]]&gt;&lt;/ac:plain-text-body&gt;&lt;/ac:structured-macro&gt;`, content)
        }</span>

        // Create processor
        <span class="cov0" title="0">processor := mermaid.NewProcessor(&amp;cfg.Mermaid, nil)

        // Process diagram to image
        result, err := processor.ProcessDiagram(content)
        if err != nil </span><span class="cov0" title="0">{
                // Return as regular code block if processing failed
                return fmt.Sprintf(`&lt;ac:structured-macro ac:name="code" ac:schema-version="1"&gt;&lt;ac:parameter ac:name="language"&gt;mermaid&lt;/ac:parameter&gt;&lt;ac:plain-text-body&gt;&lt;![CDATA[%s]]&gt;&lt;/ac:plain-text-body&gt;&lt;/ac:structured-macro&gt;`, content)
        }</span>

        // Check if we have a pageID for attachment upload
        <span class="cov0" title="0">if pageID == "" || client == nil </span><span class="cov0" title="0">{
                // For new pages or when client is not available, fall back to code block
                _ = processor.Cleanup(result) // Best effort cleanup, ignore errors
                return fmt.Sprintf(`&lt;ac:structured-macro ac:name="code" ac:schema-version="1"&gt;&lt;ac:parameter ac:name="language"&gt;mermaid&lt;/ac:parameter&gt;&lt;ac:plain-text-body&gt;&lt;![CDATA[%s]]&gt;&lt;/ac:plain-text-body&gt;&lt;/ac:structured-macro&gt;`, content)
        }</span>

        // Upload image as attachment
        <span class="cov0" title="0">attachment, err := client.UploadAttachment(pageID, result.ImagePath)
        if err != nil </span><span class="cov0" title="0">{
                // Cleanup temp file and return as code block
                _ = processor.Cleanup(result) // Best effort cleanup, ignore errors
                return fmt.Sprintf(`&lt;ac:structured-macro ac:name="code" ac:schema-version="1"&gt;&lt;ac:parameter ac:name="language"&gt;mermaid&lt;/ac:parameter&gt;&lt;ac:plain-text-body&gt;&lt;![CDATA[%s]]&gt;&lt;/ac:plain-text-body&gt;&lt;/ac:structured-macro&gt;`, content)
        }</span>

        // Determine the filename to use for the attachment reference
        <span class="cov0" title="0">filename := attachment.Title
        if filename == "" </span><span class="cov0" title="0">{
                // Fallback to the generated filename if Confluence API doesn't return it
                filename = result.Filename
        }</span>
        <span class="cov0" title="0">if filename == "" </span><span class="cov0" title="0">{
                // Final fallback to Title field if available
                filename = attachment.Title
        }</span>

        // Cleanup temp file
        <span class="cov0" title="0">_ = processor.Cleanup(result) // Best effort cleanup, ignore errors

        // Return Confluence image macro with full page width
        return fmt.Sprintf(`&lt;ac:image ac:width="100%%"&gt;&lt;ri:attachment ri:filename="%s"/&gt;&lt;/ac:image&gt;`, filename)</span>
}

// ConvertToConfluenceFormatWithImages processes markdown with image attachment support
func ConvertToConfluenceFormatWithImages(markdown string, cfg *config.Config, client *confluence.Client, pageID string, markdownFilePath string) (string, error) <span class="cov0" title="0">{
        // Process mermaid diagrams first
        content := ConvertToConfluenceFormatWithMermaid(markdown, cfg, client, pageID)

        // Now process images if we have the necessary components
        if cfg == nil || client == nil || pageID == "" || markdownFilePath == "" </span><span class="cov0" title="0">{
                // No image processing possible - return content as-is
                return content, nil
        }</span>

        // Create image processor
        <span class="cov0" title="0">imageProcessor := images.NewProcessor(&amp;cfg.Images, nil)

        // Get directory of the markdown file to resolve relative image paths
        markdownDir := filepath.Dir(markdownFilePath)

        // Find image references in the original markdown content
        imageRefs, err := imageProcessor.FindImageReferences(markdown, markdownDir)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but continue without image processing
                return content, nil
        }</span>

        // Validate image references
        <span class="cov0" title="0">validRefs, err := imageProcessor.ValidateImageReferences(imageRefs)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but continue without image processing
                return content, nil
        }</span>

        // If no valid image references, return content as-is
        <span class="cov0" title="0">if len(validRefs) == 0 </span><span class="cov0" title="0">{
                return content, nil
        }</span>

        // Process each valid image reference
        <span class="cov0" title="0">for _, ref := range validRefs </span><span class="cov0" title="0">{
                // Upload image as attachment
                attachment, err := client.UploadAttachment(pageID, ref.AbsolutePath)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip this image on upload error, continue with others
                        continue</span>
                }

                // Determine the filename for the attachment reference
                <span class="cov0" title="0">filename := attachment.Title
                if filename == "" </span><span class="cov0" title="0">{
                        filename = attachment.Title
                }</span>
                <span class="cov0" title="0">if filename == "" </span><span class="cov0" title="0">{
                        filename = images.GetImageFilename(ref.AbsolutePath)
                }</span>

                // Replace the markdown image syntax with Confluence image macro
                <span class="cov0" title="0">confluenceImageMacro := fmt.Sprintf(`&lt;ac:image&gt;&lt;ri:attachment ri:filename="%s"/&gt;&lt;/ac:image&gt;`, filename)

                // Replace in the content (note: we're working with already processed content that may have HTML)
                // We need to be careful to replace the original markdown syntax, not HTML
                content = strings.ReplaceAll(content, ref.MarkdownSyntax, confluenceImageMacro)</span>
        }

        <span class="cov0" title="0">return content, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package mermaid

import (
        "crypto/sha256"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "conflux/internal/config"
        "conflux/pkg/logger"
)

type Processor struct {
        config *config.MermaidConfig
        logger *logger.Logger
}

type ProcessResult struct {
        ImagePath   string
        ImageFormat string
        Filename    string
}

func NewProcessor(config *config.MermaidConfig, logger *logger.Logger) *Processor <span class="cov8" title="1">{
        return &amp;Processor{
                config: config,
                logger: logger,
        }
}</span>

// CheckDependencies validates that required tools are available
func (p *Processor) CheckDependencies() error <span class="cov8" title="1">{
        if p.config.Mode == "preserve" </span><span class="cov8" title="1">{
                return nil // No dependencies needed for preserve mode
        }</span>

        <span class="cov8" title="1">return p.checkCLIAvailable()</span>
}

func (p *Processor) ProcessDiagram(diagramContent string) (*ProcessResult, error) <span class="cov8" title="1">{
        if p.config.Mode == "preserve" </span><span class="cov8" title="1">{
                return nil, nil // No processing needed for preserve mode
        }</span>

        // Check if mermaid CLI is available
        <span class="cov8" title="1">if err := p.checkCLIAvailable(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("mermaid CLI not available: %w", err)
        }</span>

        // Create temporary input file
        <span class="cov0" title="0">inputFile, err := p.createTempMermaidFile(diagramContent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create temp input file: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(inputFile)

        // Generate output filename
        outputFile, err := p.generateOutputFilename(diagramContent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate output filename: %w", err)
        }</span>

        // Execute mermaid CLI
        <span class="cov0" title="0">if err := p.executeMermaidCLI(inputFile, outputFile); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute mermaid CLI: %w", err)
        }</span>

        // Verify output file was created
        <span class="cov0" title="0">if _, err := os.Stat(outputFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("output file was not created: %s", outputFile)
        }</span>

        <span class="cov0" title="0">result := &amp;ProcessResult{
                ImagePath:   outputFile,
                ImageFormat: p.config.Format,
                Filename:    filepath.Base(outputFile),
        }

        if p.logger != nil </span><span class="cov0" title="0">{
                p.logger.Debug("Successfully processed mermaid diagram to %s", outputFile)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (p *Processor) checkCLIAvailable() error <span class="cov8" title="1">{
        _, err := exec.LookPath(p.config.CLIPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("mermaid CLI '%s' not found in PATH", p.config.CLIPath)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (p *Processor) createTempMermaidFile(content string) (string, error) <span class="cov8" title="1">{
        // Create temp directory if it doesn't exist
        tempDir := filepath.Join(os.TempDir(), "conflux-mermaid")
        if err := os.MkdirAll(tempDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create temp directory: %w", err)
        }</span>

        // Generate hash-based filename to avoid collisions
        <span class="cov8" title="1">hash := sha256.Sum256([]byte(content))
        filename := fmt.Sprintf("diagram-%x.mmd", hash)
        filePath := filepath.Join(tempDir, filename)

        // Write content to file
        if err := os.WriteFile(filePath, []byte(content), 0600); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write temp file: %w", err)
        }</span>

        <span class="cov8" title="1">return filePath, nil</span>
}

func (p *Processor) generateOutputFilename(content string) (string, error) <span class="cov8" title="1">{
        // Create temp directory if it doesn't exist
        tempDir := filepath.Join(os.TempDir(), "conflux-mermaid")
        if err := os.MkdirAll(tempDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create temp directory: %w", err)
        }</span>

        // Generate hash-based filename to avoid collisions
        <span class="cov8" title="1">hash := sha256.Sum256([]byte(content))
        filename := fmt.Sprintf("diagram-%x.%s", hash, p.config.Format)
        filePath := filepath.Join(tempDir, filename)

        return filePath, nil</span>
}

func (p *Processor) executeMermaidCLI(inputFile, outputFile string) error <span class="cov0" title="0">{
        // Create puppeteer config file for sandbox issues
        puppeteerConfig := `{"args": ["--no-sandbox", "--disable-setuid-sandbox"]}`
        configFile, err := p.createPuppeteerConfigFile(puppeteerConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create puppeteer config: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(configFile)

        args := []string{
                "-i", inputFile,
                "-o", outputFile,
                "-p", configFile,
        }

        // Add theme if specified and not default
        if p.config.Theme != "" &amp;&amp; p.config.Theme != "default" </span><span class="cov0" title="0">{
                args = append(args, "-t", p.config.Theme)
        }</span>

        // Add width and height for larger diagrams
        <span class="cov0" title="0">if p.config.Width &gt; 0 </span><span class="cov0" title="0">{
                args = append(args, "-w", fmt.Sprintf("%d", p.config.Width))
        }</span>
        <span class="cov0" title="0">if p.config.Height &gt; 0 </span><span class="cov0" title="0">{
                args = append(args, "-H", fmt.Sprintf("%d", p.config.Height))
        }</span>

        // Add scale factor for higher resolution
        <span class="cov0" title="0">if p.config.Scale &gt; 0 </span><span class="cov0" title="0">{
                args = append(args, "-s", fmt.Sprintf("%.1f", p.config.Scale))
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(p.config.CLIPath, args...)

        // Capture both stdout and stderr
        var stdout, stderr strings.Builder
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if p.logger != nil </span><span class="cov0" title="0">{
                p.logger.Debug("Executing mermaid CLI: %s %s", p.config.CLIPath, strings.Join(args, " "))
        }</span>

        <span class="cov0" title="0">err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mermaid CLI failed: %w\nStdout: %s\nStderr: %s", err, stdout.String(), stderr.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (p *Processor) Cleanup(result *ProcessResult) error <span class="cov8" title="1">{
        if result == nil || result.ImagePath == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := os.Remove(result.ImagePath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup temp file %s: %w", result.ImagePath, err)
        }</span>

        <span class="cov8" title="1">if p.logger != nil </span><span class="cov8" title="1">{
                p.logger.Debug("Cleaned up temp file: %s", result.ImagePath)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateContent performs basic validation on mermaid diagram content
func ValidateContent(content string) error <span class="cov8" title="1">{
        if strings.TrimSpace(content) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("mermaid diagram content cannot be empty")
        }</span>

        // Basic check for common mermaid diagram types
        <span class="cov8" title="1">content = strings.TrimSpace(content)
        validStarters := []string{
                "graph",
                "flowchart",
                "sequenceDiagram",
                "classDiagram",
                "stateDiagram",
                "erDiagram",
                "journey",
                "gantt",
                "pie",
                "gitgraph",
                "mindmap",
                "timeline",
                "sankey-beta",
                "xychart-beta",
                "requirementDiagram",
                "C4Context",
                "C4Container",
                "C4Component",
                "C4Dynamic",
                "C4Deployment",
        }

        for _, starter := range validStarters </span><span class="cov8" title="1">{
                if strings.HasPrefix(strings.ToLower(content), strings.ToLower(starter)) </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        // Allow custom directives and comments
        <span class="cov8" title="1">if strings.HasPrefix(content, "%%") || strings.Contains(content, "graph") || strings.Contains(content, "flowchart") </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return fmt.Errorf("content does not appear to be a valid mermaid diagram")</span>
}

func (p *Processor) createPuppeteerConfigFile(config string) (string, error) <span class="cov8" title="1">{
        // Create temp file for puppeteer config
        tempFile, err := os.CreateTemp("", "conflux-puppeteer-*.json")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create temp file: %w", err)
        }</span>
        <span class="cov8" title="1">defer tempFile.Close()

        if _, err := tempFile.WriteString(config); err != nil </span><span class="cov0" title="0">{
                os.Remove(tempFile.Name())
                return "", fmt.Errorf("failed to write config: %w", err)
        }</span>

        <span class="cov8" title="1">return tempFile.Name(), nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package sync

import (
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"
)

type FileMetadata struct {
        Hash        string            `json:"hash"`
        LastSync    time.Time         `json:"last_sync"`
        PageID      string            `json:"page_id,omitempty"`
        Title       string            `json:"title"`
        ModTime     time.Time         `json:"mod_time"`
        Size        int64             `json:"size"`
        Attachments map[string]string `json:"attachments,omitempty"` // filename -&gt; hash of file content
}

type DirectoryMetadata struct {
        Hash     string    `json:"hash"`
        LastSync time.Time `json:"last_sync"`
        PageID   string    `json:"page_id,omitempty"`
        Title    string    `json:"title"`
}

type SyncMetadata struct {
        Files       map[string]FileMetadata      `json:"files"`
        Directories map[string]DirectoryMetadata `json:"directories"`
        LastSync    time.Time                    `json:"last_sync"`
        SpaceKey    string                       `json:"space_key"`
        Version     string                       `json:"version"`
        cacheDir    string
        cacheFile   string
        markdownDir string
}

func NewSyncMetadata(markdownDir, spaceKey string) *SyncMetadata <span class="cov8" title="1">{
        cacheDir := filepath.Join(markdownDir, ".conflux")
        cacheFile := filepath.Join(cacheDir, "sync-cache.json")

        return &amp;SyncMetadata{
                Files:       make(map[string]FileMetadata),
                Directories: make(map[string]DirectoryMetadata),
                SpaceKey:    spaceKey,
                Version:     "1.0",
                cacheDir:    cacheDir,
                cacheFile:   cacheFile,
                markdownDir: markdownDir,
        }
}</span>

func (sm *SyncMetadata) Load() error <span class="cov8" title="1">{
        data, err := os.ReadFile(sm.cacheFile)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to read sync cache: %w", err)</span>
        }

        <span class="cov8" title="1">if err := json.Unmarshal(data, sm); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to parse sync cache: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (sm *SyncMetadata) Save() error <span class="cov8" title="1">{
        if err := os.MkdirAll(sm.cacheDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create cache directory: %w", err)
        }</span>

        <span class="cov8" title="1">sm.LastSync = time.Now()

        data, err := json.MarshalIndent(sm, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal sync cache: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(sm.cacheFile, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write sync cache: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// normalizeFilePath converts absolute file paths to relative paths based on markdownDir
func (sm *SyncMetadata) normalizeFilePath(filePath string) string <span class="cov8" title="1">{
        if sm.markdownDir == "" </span><span class="cov8" title="1">{
                return filePath
        }</span>

        // If already relative or not under markdownDir, return as-is
        <span class="cov8" title="1">if !filepath.IsAbs(filePath) </span><span class="cov8" title="1">{
                return filePath
        }</span>

        <span class="cov8" title="1">relPath, err := filepath.Rel(sm.markdownDir, filePath)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't make it relative, use the absolute path
                return filePath
        }</span>

        <span class="cov8" title="1">return relPath</span>
}

func (sm *SyncMetadata) CalculateFileHash(filePath string) (string, error) <span class="cov8" title="1">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to open file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        hash := sha256.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to calculate hash: %w", err)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%x", hash.Sum(nil)), nil</span>
}

func (sm *SyncMetadata) GetFileStatus(filePath string) (SyncStatus, error) <span class="cov8" title="1">{
        // Normalize the file path for consistent cache lookup
        normalizedPath := sm.normalizeFilePath(filePath)

        // Get file info
        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to stat file: %w", err)
        }</span>

        // Calculate current hash
        <span class="cov8" title="1">currentHash, err := sm.CalculateFileHash(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to calculate file hash: %w", err)
        }</span>

        // Check if we have cached metadata for this file (using normalized path)
        <span class="cov8" title="1">metadata, exists := sm.Files[normalizedPath]
        if !exists </span><span class="cov8" title="1">{
                return StatusNew, nil
        }</span>

        // Compare hashes to detect changes
        <span class="cov8" title="1">if metadata.Hash != currentHash </span><span class="cov8" title="1">{
                return StatusChanged, nil
        }</span>

        // Also check modification time as a backup
        <span class="cov8" title="1">if fileInfo.ModTime().After(metadata.ModTime) </span><span class="cov0" title="0">{
                return StatusChanged, nil
        }</span>

        <span class="cov8" title="1">return StatusUpToDate, nil</span>
}

func (sm *SyncMetadata) UpdateFileMetadata(filePath, pageID, title string) error <span class="cov8" title="1">{
        // Normalize the file path for consistent cache storage
        normalizedPath := sm.normalizeFilePath(filePath)

        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to stat file: %w", err)
        }</span>

        <span class="cov8" title="1">hash, err := sm.CalculateFileHash(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate file hash: %w", err)
        }</span>

        <span class="cov8" title="1">sm.Files[normalizedPath] = FileMetadata{
                Hash:     hash,
                LastSync: time.Now(),
                PageID:   pageID,
                Title:    title,
                ModTime:  fileInfo.ModTime(),
                Size:     fileInfo.Size(),
        }

        return nil</span>
}

func (sm *SyncMetadata) RemoveFileMetadata(filePath string) <span class="cov8" title="1">{
        normalizedPath := sm.normalizeFilePath(filePath)
        delete(sm.Files, normalizedPath)
}</span>

func (sm *SyncMetadata) GetPageID(filePath string) string <span class="cov8" title="1">{
        normalizedPath := sm.normalizeFilePath(filePath)
        if metadata, exists := sm.Files[normalizedPath]; exists </span><span class="cov8" title="1">{
                return metadata.PageID
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func (sm *SyncMetadata) GetCachedFiles() []string <span class="cov8" title="1">{
        var files []string
        for filePath := range sm.Files </span><span class="cov8" title="1">{
                files = append(files, filePath)
        }</span>
        <span class="cov8" title="1">return files</span>
}

func (sm *SyncMetadata) ClearCache() error <span class="cov8" title="1">{
        sm.Files = make(map[string]FileMetadata)
        sm.Directories = make(map[string]DirectoryMetadata)
        return sm.Save()
}</span>

// CalculateDirectoryHash calculates a hash for a directory based on its markdown files
func (sm *SyncMetadata) CalculateDirectoryHash(dirPath string, files []string) string <span class="cov8" title="1">{
        hash := sha256.New()
        hash.Write([]byte(dirPath))

        // Include all files in this directory in the hash
        for _, file := range files </span><span class="cov8" title="1">{
                relPath, err := filepath.Rel(sm.markdownDir, file)
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">fileDir := filepath.Dir(relPath)
                if fileDir == dirPath || (dirPath == "." &amp;&amp; fileDir == ".") </span><span class="cov8" title="1">{
                        hash.Write([]byte(file))
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(fileDir, dirPath+string(filepath.Separator)) </span><span class="cov8" title="1">{
                        hash.Write([]byte(file))
                }</span>
        }

        <span class="cov8" title="1">return fmt.Sprintf("%x", hash.Sum(nil))</span>
}

// GetDirectoryStatus determines if a directory needs stub page creation
func (sm *SyncMetadata) GetDirectoryStatus(dirPath string, files []string) SyncStatus <span class="cov8" title="1">{
        currentHash := sm.CalculateDirectoryHash(dirPath, files)

        if metadata, exists := sm.Directories[dirPath]; exists </span><span class="cov8" title="1">{
                if metadata.Hash == currentHash </span><span class="cov8" title="1">{
                        return StatusUpToDate
                }</span>
                <span class="cov8" title="1">return StatusChanged</span>
        }

        <span class="cov8" title="1">return StatusNew</span>
}

// UpdateDirectoryMetadata updates the cached metadata for a directory
func (sm *SyncMetadata) UpdateDirectoryMetadata(dirPath, pageID, title string, files []string) <span class="cov8" title="1">{
        hash := sm.CalculateDirectoryHash(dirPath, files)

        sm.Directories[dirPath] = DirectoryMetadata{
                Hash:     hash,
                LastSync: time.Now(),
                PageID:   pageID,
                Title:    title,
        }
}</span>

// RemoveDirectoryMetadata removes cached metadata for a directory
func (sm *SyncMetadata) RemoveDirectoryMetadata(dirPath string) <span class="cov0" title="0">{
        delete(sm.Directories, dirPath)
}</span>

// GetDirectoryPageID returns the cached page ID for a directory
func (sm *SyncMetadata) GetDirectoryPageID(dirPath string) string <span class="cov8" title="1">{
        if metadata, exists := sm.Directories[dirPath]; exists </span><span class="cov8" title="1">{
                return metadata.PageID
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// GetFileAttachments returns the cached attachment hashes for a file
func (sm *SyncMetadata) GetFileAttachments(filePath string) map[string]string <span class="cov0" title="0">{
        if metadata, exists := sm.Files[filePath]; exists </span><span class="cov0" title="0">{
                if metadata.Attachments == nil </span><span class="cov0" title="0">{
                        return make(map[string]string)
                }</span>
                <span class="cov0" title="0">return metadata.Attachments</span>
        }
        <span class="cov0" title="0">return make(map[string]string)</span>
}

// UpdateFileAttachment updates the cached attachment hash for a file
func (sm *SyncMetadata) UpdateFileAttachment(filePath, filename, hash string) <span class="cov0" title="0">{
        if metadata, exists := sm.Files[filePath]; exists </span><span class="cov0" title="0">{
                if metadata.Attachments == nil </span><span class="cov0" title="0">{
                        metadata.Attachments = make(map[string]string)
                }</span>
                <span class="cov0" title="0">metadata.Attachments[filename] = hash
                sm.Files[filePath] = metadata</span>
        }
}

// RemoveFileAttachment removes a cached attachment for a file
func (sm *SyncMetadata) RemoveFileAttachment(filePath, filename string) <span class="cov0" title="0">{
        if metadata, exists := sm.Files[filePath]; exists </span><span class="cov0" title="0">{
                if metadata.Attachments != nil </span><span class="cov0" title="0">{
                        delete(metadata.Attachments, filename)
                        sm.Files[filePath] = metadata
                }</span>
        }
}

// AttachmentChanged checks if an attachment has changed based on file hash
func (sm *SyncMetadata) AttachmentChanged(filePath, filename, currentHash string) bool <span class="cov0" title="0">{
        attachments := sm.GetFileAttachments(filePath)
        cachedHash, exists := attachments[filename]
        return !exists || cachedHash != currentHash
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package sync

import (
        "bufio"
        "fmt"
        "os"
        "strconv"
        "strings"
)

type PromptChoice struct {
        Key         string
        Description string
        Default     bool
}

type UserChoice struct {
        Action        string // "continue", "cancel", "select"
        SelectedFiles []string
        Indices       []int // 0-based indices for file selection
}

func PromptUser(message string, choices []PromptChoice) string <span class="cov0" title="0">{
        scanner := bufio.NewScanner(os.Stdin)

        for </span><span class="cov0" title="0">{
                fmt.Printf("%s ", message)

                // Show choices
                var choiceStr []string
                var defaultChoice string
                for _, choice := range choices </span><span class="cov0" title="0">{
                        if choice.Default </span><span class="cov0" title="0">{
                                choiceStr = append(choiceStr, strings.ToUpper(choice.Key))
                                defaultChoice = choice.Key
                        }</span> else<span class="cov0" title="0"> {
                                choiceStr = append(choiceStr, choice.Key)
                        }</span>
                }
                <span class="cov0" title="0">fmt.Printf("[%s]: ", strings.Join(choiceStr, "/"))

                if !scanner.Scan() </span><span class="cov0" title="0">{
                        return "cancel"
                }</span>

                <span class="cov0" title="0">input := strings.TrimSpace(strings.ToLower(scanner.Text()))
                if input == "" </span><span class="cov0" title="0">{
                        input = defaultChoice
                }</span>

                // Validate input
                <span class="cov0" title="0">for _, choice := range choices </span><span class="cov0" title="0">{
                        if strings.ToLower(choice.Key) == input </span><span class="cov0" title="0">{
                                return input
                        }</span>
                }

                <span class="cov0" title="0">fmt.Println("Invalid choice. Please try again.")</span>
        }
}

func PromptForConfirmation(summary string, changedCount, newCount, upToDateCount int) UserChoice <span class="cov0" title="0">{
        fmt.Println("\n" + summary)
        fmt.Printf("\nüìä Summary: %d changed, %d new, %d up-to-date\n", changedCount, newCount, upToDateCount)

        if changedCount == 0 &amp;&amp; newCount == 0 </span><span class="cov0" title="0">{
                fmt.Println("‚úÖ All pages are up-to-date. Nothing to sync.")
                return UserChoice{Action: "cancel"}
        }</span>

        <span class="cov0" title="0">choices := []PromptChoice{
                {Key: "y", Description: "Yes, continue with sync", Default: true},
                {Key: "n", Description: "No, cancel sync", Default: false},
        }

        if changedCount &gt; 0 || newCount &gt; 0 </span><span class="cov0" title="0">{
                choices = append(choices, PromptChoice{Key: "s", Description: "Select specific files", Default: false})
        }</span>

        <span class="cov0" title="0">choice := PromptUser("\nProceed with sync?", choices)

        switch choice </span>{
        case "y":<span class="cov0" title="0">
                return UserChoice{Action: "continue"}</span>
        case "n":<span class="cov0" title="0">
                return UserChoice{Action: "cancel"}</span>
        case "s":<span class="cov0" title="0">
                return PromptForFileSelection()</span>
        default:<span class="cov0" title="0">
                return UserChoice{Action: "cancel"}</span>
        }
}

func PromptForFileSelection() UserChoice <span class="cov0" title="0">{
        fmt.Println("\nüéØ File Selection Mode")
        fmt.Println("Enter the numbers of files to sync (comma-separated), or 'a' for all, 'c' to cancel:")

        scanner := bufio.NewScanner(os.Stdin)
        if !scanner.Scan() </span><span class="cov0" title="0">{
                return UserChoice{Action: "cancel"}
        }</span>

        <span class="cov0" title="0">input := strings.TrimSpace(strings.ToLower(scanner.Text()))
        if input == "c" </span><span class="cov0" title="0">{
                return UserChoice{Action: "cancel"}
        }</span>
        <span class="cov0" title="0">if input == "a" </span><span class="cov0" title="0">{
                return UserChoice{Action: "continue"}
        }</span>

        // Parse comma-separated numbers
        <span class="cov0" title="0">parts := strings.Split(input, ",")
        var indices []int
        for _, part := range parts </span><span class="cov0" title="0">{
                part = strings.TrimSpace(part)
                if idx, err := strconv.Atoi(part); err == nil &amp;&amp; idx &gt; 0 </span><span class="cov0" title="0">{
                        indices = append(indices, idx-1) // Convert to 0-based
                }</span>
        }

        <span class="cov0" title="0">return UserChoice{
                Action:        "select",
                Indices:       indices,
                SelectedFiles: make([]string, len(indices)), // Placeholder, will be populated by caller using indices
                // Note: The actual file paths will be populated by the caller
                // using these indices
        }</span>
}

func DisplayFileList(pages []PageSyncInfo, showOnlyChanges bool) map[int]string <span class="cov0" title="0">{
        fmt.Println("\nüìã Files to be synced:")
        fmt.Println(strings.Repeat("‚îÄ", 80))

        fileMap := make(map[int]string)
        index := 1

        for _, page := range pages </span><span class="cov0" title="0">{
                if showOnlyChanges &amp;&amp; page.Status == StatusUpToDate </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Show directory pages
                <span class="cov0" title="0">if page.IsDirectory </span><span class="cov0" title="0">{
                        fmt.Printf("%3d. üìÅ %s (directory page)\n", index, page.Title)
                        fileMap[index-1] = page.FilePath
                        index++
                }</span> else<span class="cov0" title="0"> {
                        var icon string
                        switch page.Status </span>{
                        case StatusNew:<span class="cov0" title="0">
                                icon = "üÜï"</span>
                        case StatusChanged:<span class="cov0" title="0">
                                icon = "üìù"</span>
                        case StatusUpToDate:<span class="cov0" title="0">
                                icon = "‚úÖ"</span>
                        default:<span class="cov0" title="0">
                                icon = "üìÑ"</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("%3d. %s %s\n", index, icon, page.Title)
                        fmt.Printf("     üìÇ %s\n", page.FilePath)
                        fileMap[index-1] = page.FilePath
                        index++</span>
                }
        }

        <span class="cov0" title="0">fmt.Println(strings.Repeat("‚îÄ", 80))
        return fileMap</span>
}

func ConfirmDestructiveOperation(message string) bool <span class="cov0" title="0">{
        choices := []PromptChoice{
                {Key: "n", Description: "No, cancel", Default: true},
                {Key: "y", Description: "Yes, continue", Default: false},
        }

        fmt.Printf("‚ö†Ô∏è  %s\n", message)
        choice := PromptUser("Are you sure?", choices)
        return choice == "y"
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package sync

import (
        "fmt"
        "sort"
        "strings"
)

// RenameDetection represents a detected page/folder rename situation
type RenameDetection struct {
        Type           string // "page" or "directory" 
        LocalPath      string // Current local path/title
        ExpectedTitle  string // What Conflux expects based on local structure
        ActualTitle    string // What exists in Confluence
        PageID         string // Confluence page ID
        CachedTitle    string // Title stored in cache
        Severity       string // "warning" or "critical"
        Recommendation string // What user should do
}

// DetectRenames analyzes the sync plan and detects potential rename issues
func (s *Syncer) DetectRenames(pages []PageSyncInfo) ([]RenameDetection, error) <span class="cov8" title="1">{
        var detections []RenameDetection
        
        s.logger.Debug("Running rename detection analysis...")
        
        // Check directory renames
        for _, page := range pages </span><span class="cov8" title="1">{
                if page.IsDirectory </span><span class="cov8" title="1">{
                        detection := s.checkDirectoryRename(page)
                        if detection != nil </span><span class="cov0" title="0">{
                                detections = append(detections, *detection)
                        }</span>
                } else<span class="cov8" title="1"> {
                        detection := s.checkPageRename(page)
                        if detection != nil </span><span class="cov0" title="0">{
                                detections = append(detections, *detection)
                        }</span>
                }
        }
        
        // Check for orphaned pages (cached pages that don't match current structure)
        <span class="cov8" title="1">orphanDetections := s.checkOrphanedPages(pages)
        detections = append(detections, orphanDetections...)
        
        s.logger.Debug("Rename detection found %d potential issues", len(detections))
        return detections, nil</span>
}

// checkDirectoryRename detects when a directory has been renamed locally
func (s *Syncer) checkDirectoryRename(page PageSyncInfo) *RenameDetection <span class="cov8" title="1">{
        cachedPageID := s.metadata.GetDirectoryPageID(page.FilePath)
        if cachedPageID == "" </span><span class="cov8" title="1">{
                return nil // No cached page, not a rename
        }</span>
        
        // Get the actual page from Confluence
        <span class="cov8" title="1">existingPage, err := s.confluence.GetPage(cachedPageID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Could not retrieve page for rename check: %s", cachedPageID)
                return nil
        }</span>
        
        // Compare expected title vs actual title
        <span class="cov8" title="1">if existingPage.Title != page.Title </span><span class="cov0" title="0">{
                // Get cached title if available
                cachedTitle := ""
                if metadata, exists := s.metadata.Directories[page.FilePath]; exists </span><span class="cov0" title="0">{
                        cachedTitle = metadata.Title
                }</span>
                
                <span class="cov0" title="0">severity := "warning"
                recommendation := fmt.Sprintf("Directory renamed from '%s' to '%s'. Children macro may not work properly.", 
                        existingPage.Title, page.Title)
                        
                // If there are many children, this becomes critical
                if s.hasChildPages(cachedPageID) </span><span class="cov0" title="0">{
                        severity = "critical"
                        recommendation += " Consider manually moving child pages or clearing cache."
                }</span>
                
                <span class="cov0" title="0">return &amp;RenameDetection{
                        Type:           "directory",
                        LocalPath:      page.FilePath,
                        ExpectedTitle:  page.Title,
                        ActualTitle:    existingPage.Title,
                        PageID:         cachedPageID,
                        CachedTitle:    cachedTitle,
                        Severity:       severity,
                        Recommendation: recommendation,
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// checkPageRename detects when a page has been renamed locally or in Confluence
func (s *Syncer) checkPageRename(page PageSyncInfo) *RenameDetection <span class="cov8" title="1">{
        cachedPageID := s.metadata.GetPageID(page.FilePath)
        if cachedPageID == "" </span><span class="cov8" title="1">{
                return nil // No cached page, not a rename
        }</span>
        
        // Get the actual page from Confluence
        <span class="cov8" title="1">existingPage, err := s.confluence.GetPage(cachedPageID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Could not retrieve page for rename check: %s", cachedPageID)
                return nil
        }</span>
        
        // Compare expected title vs actual title
        <span class="cov8" title="1">if existingPage.Title != page.Title </span><span class="cov0" title="0">{
                // Get cached title if available
                cachedTitle := ""
                if metadata, exists := s.metadata.Files[page.FilePath]; exists </span><span class="cov0" title="0">{
                        cachedTitle = metadata.Title
                }</span>
                
                // Determine if rename was local or remote
                <span class="cov0" title="0">var recommendation string
                if cachedTitle == page.Title </span><span class="cov0" title="0">{
                        // Local title matches cache, so rename happened in Confluence
                        recommendation = fmt.Sprintf("Page renamed in Confluence from '%s' to '%s'. Conflux will preserve the Confluence title.", 
                                page.Title, existingPage.Title)
                }</span> else<span class="cov0" title="0"> if cachedTitle == existingPage.Title </span><span class="cov0" title="0">{
                        // Confluence title matches cache, so rename happened locally  
                        recommendation = fmt.Sprintf("Page renamed locally from '%s' to '%s'. Conflux will update the Confluence page title.", 
                                existingPage.Title, page.Title)
                }</span> else<span class="cov0" title="0"> {
                        // Both sides changed - conflict situation
                        recommendation = fmt.Sprintf("Title conflict detected. Local: '%s', Confluence: '%s', Cached: '%s'. Manual resolution may be needed.", 
                                page.Title, existingPage.Title, cachedTitle)
                }</span>
                
                <span class="cov0" title="0">return &amp;RenameDetection{
                        Type:           "page",
                        LocalPath:      page.FilePath,
                        ExpectedTitle:  page.Title,
                        ActualTitle:    existingPage.Title,
                        PageID:         cachedPageID,
                        CachedTitle:    cachedTitle,
                        Severity:       "warning",
                        Recommendation: recommendation,
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// checkOrphanedPages finds pages in cache that no longer exist locally
func (s *Syncer) checkOrphanedPages(pages []PageSyncInfo) []RenameDetection <span class="cov8" title="1">{
        var detections []RenameDetection
        
        // Build set of current local paths
        localPaths := make(map[string]bool)
        for _, page := range pages </span><span class="cov8" title="1">{
                localPaths[page.FilePath] = true
        }</span>
        
        // Check cached files that are no longer local
        <span class="cov8" title="1">for filePath, metadata := range s.metadata.Files </span><span class="cov8" title="1">{
                if !localPaths[filePath] </span><span class="cov8" title="1">{
                        // This file was cached but no longer exists locally
                        detections = append(detections, RenameDetection{
                                Type:           "page",
                                LocalPath:      filePath + " (DELETED)",
                                ExpectedTitle:  "",
                                ActualTitle:    metadata.Title,
                                PageID:         metadata.PageID,
                                CachedTitle:    metadata.Title,
                                Severity:       "warning",
                                Recommendation: fmt.Sprintf("Local file deleted but Confluence page '%s' still exists. Consider manual cleanup.", metadata.Title),
                        })
                }</span>
        }
        
        // Check cached directories that are no longer local
        <span class="cov8" title="1">for dirPath, metadata := range s.metadata.Directories </span><span class="cov8" title="1">{
                if !localPaths[dirPath] </span><span class="cov0" title="0">{
                        // This directory was cached but no longer exists locally
                        detections = append(detections, RenameDetection{
                                Type:           "directory",
                                LocalPath:      dirPath + " (DELETED)",
                                ExpectedTitle:  "",
                                ActualTitle:    metadata.Title,
                                PageID:         metadata.PageID,
                                CachedTitle:    metadata.Title,
                                Severity:       "critical",
                                Recommendation: fmt.Sprintf("Local directory deleted but Confluence directory page '%s' still exists with potential child pages. Manual cleanup recommended.", metadata.Title),
                        })
                }</span>
        }
        
        <span class="cov8" title="1">return detections</span>
}

// hasChildPages checks if a page has child pages (for determining severity)
func (s *Syncer) hasChildPages(pageID string) bool <span class="cov0" title="0">{
        children, err := s.confluence.GetChildPages(pageID)
        return err == nil &amp;&amp; len(children) &gt; 0
}</span>

// DisplayRenameDetections shows rename detection results to user
func (s *Syncer) DisplayRenameDetections(detections []RenameDetection) <span class="cov8" title="1">{
        if len(detections) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Sort by severity (critical first, then warnings)
        <span class="cov8" title="1">sort.Slice(detections, func(i, j int) bool </span><span class="cov8" title="1">{
                if detections[i].Severity != detections[j].Severity </span><span class="cov0" title="0">{
                        return detections[i].Severity == "critical"
                }</span>
                <span class="cov8" title="1">return detections[i].LocalPath &lt; detections[j].LocalPath</span>
        })
        
        <span class="cov8" title="1">fmt.Println()
        fmt.Println("üîç Rename Detection Analysis:")
        fmt.Println(strings.Repeat("=", 50))
        
        criticalCount := 0
        warningCount := 0
        
        for i, detection := range detections </span><span class="cov8" title="1">{
                if detection.Severity == "critical" </span><span class="cov0" title="0">{
                        criticalCount++
                        fmt.Printf("üö® CRITICAL #%d: %s Rename Detected\n", criticalCount, strings.Title(detection.Type))
                }</span> else<span class="cov8" title="1"> {
                        warningCount++
                        fmt.Printf("‚ö†Ô∏è  WARNING #%d: %s Rename Detected\n", warningCount, strings.Title(detection.Type))
                }</span>
                
                <span class="cov8" title="1">fmt.Printf("   üìÅ Local Path: %s\n", detection.LocalPath)
                if detection.ExpectedTitle != "" </span><span class="cov0" title="0">{
                        fmt.Printf("   üìù Expected Title: %s\n", detection.ExpectedTitle)
                }</span>
                <span class="cov8" title="1">fmt.Printf("   üåê Confluence Title: %s\n", detection.ActualTitle)
                if detection.CachedTitle != "" &amp;&amp; detection.CachedTitle != detection.ActualTitle </span><span class="cov0" title="0">{
                        fmt.Printf("   üíæ Cached Title: %s\n", detection.CachedTitle)
                }</span>
                <span class="cov8" title="1">fmt.Printf("   üîó Page ID: %s\n", detection.PageID)
                fmt.Printf("   üí° %s\n", detection.Recommendation)
                
                if i &lt; len(detections)-1 </span><span class="cov8" title="1">{
                        fmt.Println()
                }</span>
        }
        
        <span class="cov8" title="1">fmt.Println()
        fmt.Printf("üìä Summary: %d critical issues, %d warnings detected\n", criticalCount, warningCount)
        
        if criticalCount &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println()
                fmt.Println("üéØ Recommended Actions:")
                fmt.Println("1. Review critical issues above - they may cause broken parent-child relationships")
                fmt.Println("2. Use 'conflux inspect' command to examine current page hierarchy")
                fmt.Println("3. Consider manually fixing page relationships in Confluence")
                fmt.Println("4. Or clear cache with 'rm -rf .conflux/' and re-sync")
        }</span>
        
        <span class="cov8" title="1">fmt.Println()</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">package sync

import (
        "fmt"
        "path/filepath"
        "strings"
        "time"

        "golang.org/x/text/cases"
        "golang.org/x/text/language"

        "conflux/internal/config"
        "conflux/internal/confluence"
        "conflux/internal/images"
        "conflux/internal/markdown"
        "conflux/internal/mermaid"
        "conflux/pkg/logger"
)

type SyncStatus string

const (
        StatusNew      SyncStatus = "new"
        StatusChanged  SyncStatus = "changed"
        StatusUpToDate SyncStatus = "up-to-date"
)

type PageSyncInfo struct {
        Title       string
        FilePath    string
        Status      SyncStatus
        Level       int
        Children    []PageSyncInfo
        ParentPath  string // Directory path that should be the parent page
        IsDirectory bool   // True if this represents a directory page
}

type Syncer struct {
        config     *config.Config
        confluence confluence.ConfluenceClient
        logger     *logger.Logger
        metadata   *SyncMetadata
}

func New(cfg *config.Config, log *logger.Logger) *Syncer <span class="cov8" title="1">{
        client := confluence.NewClient(
                cfg.Confluence.BaseURL,
                cfg.Confluence.Username,
                cfg.Confluence.APIToken,
                log,
        )

        metadata := NewSyncMetadata(cfg.Local.MarkdownDir, cfg.Confluence.SpaceKey)

        return &amp;Syncer{
                config:     cfg,
                confluence: client,
                logger:     log,
                metadata:   metadata,
        }
}</span>

// NewWithClient creates a syncer with a custom confluence client (useful for testing)
func NewWithClient(cfg *config.Config, log *logger.Logger, client confluence.ConfluenceClient) *Syncer <span class="cov8" title="1">{
        metadata := NewSyncMetadata(cfg.Local.MarkdownDir, cfg.Confluence.SpaceKey)

        return &amp;Syncer{
                config:     cfg,
                confluence: client,
                logger:     log,
                metadata:   metadata,
        }
}</span>

func (s *Syncer) Sync(dryRun bool, force bool) error <span class="cov8" title="1">{
        return s.SyncWithFile(dryRun, force, false, "")
}</span>

func (s *Syncer) SyncWithFile(dryRun bool, force bool, forceStubs bool, singleFilePath string) error <span class="cov8" title="1">{
        s.logger.Info("Starting sync process...")

        // Load sync metadata cache
        if err := s.metadata.Load(); err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Could not load sync cache (will create new): %v", err)
        }</span>

        // Check mermaid dependencies if mermaid mode requires CLI
        <span class="cov8" title="1">if s.config.Mermaid.Mode == "convert-to-image" </span><span class="cov0" title="0">{
                processor := mermaid.NewProcessor(&amp;s.config.Mermaid, s.logger)
                if err := processor.CheckDependencies(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Mermaid CLI dependencies not met: %v", err)
                        s.logger.Info("Install mermaid CLI: npm install -g @mermaid-js/mermaid-cli")
                        return fmt.Errorf("mermaid dependencies not available: %w", err)
                }</span>
                <span class="cov0" title="0">s.logger.Info("Mermaid CLI dependencies verified")</span>
        }

        <span class="cov8" title="1">var files []string
        var err error

        if singleFilePath != "" </span><span class="cov0" title="0">{
                // Single file mode: use FindMarkdownFiles for validation
                files, err = markdown.FindMarkdownFiles(singleFilePath, []string{})
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to process file %s: %w", singleFilePath, err)
                }</span>
                <span class="cov0" title="0">s.logger.Info("Single file mode: processing %s", singleFilePath)</span>
        } else<span class="cov8" title="1"> {
                // Directory mode: find all markdown files
                files, err = markdown.FindMarkdownFiles(s.config.Local.MarkdownDir, s.config.Local.Exclude)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find markdown files: %w", err)
                }</span>
                <span class="cov8" title="1">s.logger.Info("Found %d markdown files to analyze", len(files))</span>
        }

        // Analyze all files and build page hierarchy
        <span class="cov8" title="1">pages, err := s.analyzeAllFiles(files, forceStubs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to analyze files: %w", err)
        }</span>

        // Run rename detection analysis
        <span class="cov8" title="1">renameDetections, err := s.DetectRenames(pages)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Rename detection failed: %v", err)
        }</span> else<span class="cov8" title="1"> if len(renameDetections) &gt; 0 </span><span class="cov8" title="1">{
                s.DisplayRenameDetections(renameDetections)
        }</span>

        // Count status types
        <span class="cov8" title="1">var newCount, changedCount, upToDateCount int
        for _, page := range pages </span><span class="cov8" title="1">{
                switch page.Status </span>{
                case StatusNew:<span class="cov8" title="1">
                        newCount++</span>
                case StatusChanged:<span class="cov0" title="0">
                        changedCount++</span>
                case StatusUpToDate:<span class="cov8" title="1">
                        upToDateCount++</span>
                }
        }

        // Display hierarchy and get user confirmation (unless it's a dry run or force mode)
        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                s.displayEnhancedHierarchy(pages, newCount, changedCount, upToDateCount, true)
                return nil
        }</span>

        <span class="cov8" title="1">s.displayEnhancedHierarchy(pages, newCount, changedCount, upToDateCount, false)

        if !force </span><span class="cov0" title="0">{
                choice := PromptForConfirmation("Sync Preview", changedCount, newCount, upToDateCount)
                switch choice.Action </span>{
                case "cancel":<span class="cov0" title="0">
                        fmt.Println("‚ùå Sync canceled by user")
                        return nil</span>
                case "select":<span class="cov0" title="0">
                        // Display file list for selection
                        _ = DisplayFileList(pages, true)
                        selectionChoice := PromptForFileSelection()
                        if selectionChoice.Action == "cancel" </span><span class="cov0" title="0">{
                                fmt.Println("‚ùå Sync canceled by user")
                                return nil
                        }</span>
                        // TODO: Implement selective sync based on user selection
                        // For now, proceed with all files
                case "continue":<span class="cov0" title="0"></span>
                        // Proceed with sync
                }
        }

        // Perform the actual sync
        <span class="cov8" title="1">return s.performEnhancedSync(pages)</span>
}

func (s *Syncer) extractDirectories(files []string) []string <span class="cov8" title="1">{
        dirSet := make(map[string]bool)

        for _, file := range files </span><span class="cov8" title="1">{
                relPath, err := filepath.Rel(s.config.Local.MarkdownDir, file)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">dir := filepath.Dir(relPath)
                if dir != "." </span><span class="cov8" title="1">{
                        // Add all directory levels
                        parts := strings.Split(dir, string(filepath.Separator))
                        currentPath := ""
                        for _, part := range parts </span><span class="cov8" title="1">{
                                if currentPath == "" </span><span class="cov8" title="1">{
                                        currentPath = part
                                }</span> else<span class="cov8" title="1"> {
                                        currentPath = filepath.Join(currentPath, part)
                                }</span>
                                <span class="cov8" title="1">dirSet[currentPath] = true</span>
                        }
                }
        }

        // Convert to sorted slice
        <span class="cov8" title="1">var directories []string
        for dir := range dirSet </span><span class="cov8" title="1">{
                directories = append(directories, dir)
        }</span>

        // Sort by depth (shallow first) so we create parent directories before children
        <span class="cov8" title="1">for i := 0; i &lt; len(directories)-1; i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(directories); j++ </span><span class="cov8" title="1">{
                        if strings.Count(directories[i], string(filepath.Separator)) &gt; strings.Count(directories[j], string(filepath.Separator)) </span><span class="cov8" title="1">{
                                directories[i], directories[j] = directories[j], directories[i]
                        }</span>
                }
        }

        <span class="cov8" title="1">return directories</span>
}

func (s *Syncer) createDirectoryPage(dirPath, parentDirPath string, directoryPages map[string]*confluence.Page, status SyncStatus, files []string) (*confluence.Page, error) <span class="cov8" title="1">{
        // Check if directory page already exists in our cache
        if page, exists := directoryPages[dirPath]; exists </span><span class="cov0" title="0">{
                return page, nil
        }</span>

        // Skip creation if directory is up-to-date
        <span class="cov8" title="1">if status == StatusUpToDate </span><span class="cov8" title="1">{
                s.logger.Debug("Directory page is up-to-date, skipping: %s", dirPath)

                // Use enhanced fallback lookup
                dirName := filepath.Base(dirPath)
                cachedPageID := s.metadata.GetDirectoryPageID(dirPath)

                if existingPage, err := s.findPageWithFallback(dirName, cachedPageID); err == nil &amp;&amp; existingPage != nil </span><span class="cov8" title="1">{
                        directoryPages[dirPath] = existingPage
                        return existingPage, nil
                }</span>
        }

        // Create directory page title from the directory name
        <span class="cov8" title="1">dirName := filepath.Base(dirPath)
        caser := cases.Title(language.English)
        title := caser.String(strings.ReplaceAll(dirName, "-", " "))

        s.logger.Info("Creating directory page: %s (status: %s)", title, status)

        // Enhanced content for directory page with child items display
        content := fmt.Sprintf(`&lt;h1&gt;%s&lt;/h1&gt;
&lt;p&gt;This section contains documentation for %s. The pages below are automatically listed and updated whenever child pages are added or modified.&lt;/p&gt;

&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ac:structured-macro ac:name="children" ac:schema-version="1"&gt;
&lt;ac:parameter ac:name="all"&gt;true&lt;/ac:parameter&gt;
&lt;ac:parameter ac:name="sort"&gt;title&lt;/ac:parameter&gt;
&lt;/ac:structured-macro&gt;

&lt;p&gt;&lt;em&gt;This page was automatically created by &lt;a href="https://github.com/gdesouza/conflux"&gt;Conflux&lt;/a&gt; to organize documentation hierarchy.&lt;/em&gt;&lt;/p&gt;`, title, dirName)

        var page *confluence.Page
        var err error

        // Determine parent page ID
        var parentID string
        if parentDirPath != "" </span><span class="cov8" title="1">{
                if parentPage, exists := directoryPages[parentDirPath]; exists </span><span class="cov8" title="1">{
                        parentID = parentPage.ID
                }</span>
        }

        // Check if the directory page already exists in Confluence using enhanced fallback
        // Use cached page ID to properly find renamed pages
        <span class="cov8" title="1">cachedPageID := s.metadata.GetDirectoryPageID(dirPath)
        existingPage, err := s.findPageWithFallback(title, cachedPageID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Info("Could not check for existing directory page (creating new): %s", title)
        }</span>

        <span class="cov8" title="1">if existingPage != nil </span><span class="cov8" title="1">{
                s.logger.Info("Directory page already exists (ID: %s), updating content: %s", existingPage.ID, existingPage.Title)
                s.logger.Debug("Existing page content length: %d bytes", len(existingPage.Body.Storage.Value))
                s.logger.Debug("New stub content length: %d bytes", len(content))

                // Use the existing page's current title instead of the generated title to preserve user renames
                actualTitle := existingPage.Title
                s.logger.Debug("Using existing page title '%s' instead of generated title '%s'", actualTitle, title)

                // Update content with the actual page title
                content = fmt.Sprintf(`&lt;h1&gt;%s&lt;/h1&gt;
&lt;p&gt;This section contains documentation for %s. The pages below are automatically listed and updated whenever child pages are added or modified.&lt;/p&gt;

&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ac:structured-macro ac:name="children" ac:schema-version="1"&gt;
&lt;ac:parameter ac:name="all"&gt;true&lt;/ac:parameter&gt;
&lt;ac:parameter ac:name="sort"&gt;title&lt;/ac:parameter&gt;
&lt;/ac:structured-macro&gt;

&lt;p&gt;&lt;em&gt;This page was automatically created by &lt;a href="https://github.com/gdesouza/conflux"&gt;Conflux&lt;/a&gt; to organize documentation hierarchy.&lt;/em&gt;&lt;/p&gt;`, actualTitle, dirName)

                // Update the existing directory page with new content (preserve the existing title)
                s.logger.Debug("Attempting to update page ID: %s with new content", existingPage.ID)
                var updatedPage *confluence.Page
                updatedPage, err = s.confluence.UpdatePage(existingPage.ID, actualTitle, content)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Info("Failed to update directory page, will recreate: %s", err)
                }</span> else<span class="cov8" title="1"> {
                        s.logger.Info("Successfully updated directory page: %s (ID: %s)", actualTitle, updatedPage.ID)
                        directoryPages[dirPath] = updatedPage
                        // Update directory metadata with the actual title from Confluence
                        s.metadata.UpdateDirectoryMetadata(dirPath, updatedPage.ID, actualTitle, files)
                        return updatedPage, nil
                }</span>
        }

        // Create the directory page
        <span class="cov8" title="1">if parentID != "" </span><span class="cov8" title="1">{
                page, err = s.confluence.CreatePageWithParent(s.config.Confluence.SpaceKey, title, content, parentID)
        }</span> else<span class="cov8" title="1"> {
                page, err = s.confluence.CreatePage(s.config.Confluence.SpaceKey, title, content)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create directory page: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Info("Successfully created directory page: %s (ID: %s)", title, page.ID)
        directoryPages[dirPath] = page

        // Update directory metadata
        s.metadata.UpdateDirectoryMetadata(dirPath, page.ID, title, files)

        return page, nil</span>
}

func (s *Syncer) analyzeAllFiles(files []string, forceStubs bool) ([]PageSyncInfo, error) <span class="cov8" title="1">{
        var pages []PageSyncInfo

        // First, create directory page info with change detection
        directories := s.extractDirectories(files)
        for _, dir := range directories </span><span class="cov8" title="1">{
                dirName := filepath.Base(dir)
                caser := cases.Title(language.English)
                title := caser.String(strings.ReplaceAll(dirName, "-", " "))
                level := strings.Count(dir, string(filepath.Separator))

                // Check if directory needs stub page creation
                status := s.metadata.GetDirectoryStatus(dir, files)

                // Force regeneration of directory stub pages if requested
                if forceStubs &amp;&amp; (status == StatusUpToDate || status == StatusNew) </span><span class="cov0" title="0">{
                        // For StatusNew, we still want to force update if the page exists in Confluence
                        if status == StatusNew </span><span class="cov0" title="0">{
                                // Quick check if page exists in Confluence
                                dirName := filepath.Base(dir)
                                cachedPageID := s.metadata.GetDirectoryPageID(dir)
                                if existingPage, err := s.findPageWithFallback(dirName, cachedPageID); err == nil &amp;&amp; existingPage != nil </span><span class="cov0" title="0">{
                                        status = StatusChanged
                                        s.logger.Debug("Forcing directory stub regeneration for existing page: %s", dir)
                                }</span> else<span class="cov0" title="0"> {
                                        // Keep StatusNew if page doesn't exist
                                        s.logger.Debug("Directory page doesn't exist, keeping StatusNew: %s", dir)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                status = StatusChanged
                                s.logger.Debug("Forcing directory stub regeneration for: %s", dir)
                        }</span>
                }

                <span class="cov8" title="1">pages = append(pages, PageSyncInfo{
                        Title:       title,
                        FilePath:    dir,
                        Status:      status,
                        Level:       level,
                        IsDirectory: true,
                })</span>
        }

        // Then analyze markdown files with enhanced change detection
        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                pageInfo, err := s.analyzeFileWithMetadata(file)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to analyze file %s: %v", file, err)
                        continue</span>
                }
                <span class="cov8" title="1">pages = append(pages, pageInfo)</span>
        }

        <span class="cov8" title="1">return pages, nil</span>
}

func (s *Syncer) analyzeFileWithMetadata(filePath string) (PageSyncInfo, error) <span class="cov8" title="1">{
        s.logger.Debug("Analyzing file with metadata: %s", filePath)

        doc, err := markdown.ParseFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return PageSyncInfo{}, fmt.Errorf("failed to parse markdown: %w", err)
        }</span>

        // Use metadata-based change detection
        <span class="cov8" title="1">status, err := s.metadata.GetFileStatus(filePath)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Could not determine file status from metadata, assuming changed: %v", err)
                status = StatusChanged
        }</span>

        // If metadata shows up-to-date, double-check with Confluence (if accessible)
        <span class="cov8" title="1">if status == StatusUpToDate </span><span class="cov8" title="1">{
                // Use enhanced fallback lookup to handle title transformations
                cachedPageID := s.metadata.GetPageID(filePath)
                existingPage, err := s.findPageWithFallback(doc.Title, cachedPageID)
                if err != nil </span><span class="cov0" title="0">{
                        // Can't connect to Confluence, trust metadata
                        s.logger.Debug("Cannot verify with Confluence, trusting metadata for: %s", doc.Title)
                }</span> else<span class="cov8" title="1"> if existingPage == nil </span><span class="cov0" title="0">{
                        // Page doesn't exist in Confluence but metadata says up-to-date
                        // This could happen if page was deleted externally
                        status = StatusNew
                }</span>
        }

        <span class="cov8" title="1">return PageSyncInfo{
                Title:    doc.Title,
                FilePath: filePath,
                Status:   status,
                Level:    0, // Will be calculated based on directory structure
        }, nil</span>
}

func (s *Syncer) displayEnhancedHierarchy(pages []PageSyncInfo, newCount, changedCount, upToDateCount int, isDryRun bool) <span class="cov8" title="1">{
        if isDryRun </span><span class="cov8" title="1">{
                fmt.Printf("üîç Dry Run - Space '%s':\n\n", s.config.Confluence.SpaceKey)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("üè¢ Space '%s' - Sync Preview:\n\n", s.config.Confluence.SpaceKey)
        }</span>

        // Build and display tree
        <span class="cov8" title="1">tree := s.buildPageTree(pages)
        s.printEnhancedPageTree(tree, 0)

        // Display summary
        fmt.Printf("\nüìä Summary:\n")
        fmt.Printf("   üÜï New pages: %d\n", newCount)
        fmt.Printf("   üìù Changed pages: %d\n", changedCount)
        fmt.Printf("   ‚úÖ Up-to-date pages: %d\n", upToDateCount)
        fmt.Printf("   üìÑ Total pages: %d\n\n", len(pages))

        if isDryRun </span><span class="cov8" title="1">{
                fmt.Println("üí° This is a dry run. No changes will be made.")
                fmt.Println("   Run without --dry-run to perform the actual sync.")
        }</span>
}

func (s *Syncer) buildPageTree(pages []PageSyncInfo) []PageSyncInfo <span class="cov8" title="1">{
        // Create maps for organizing pages
        pageMap := make(map[string]*PageSyncInfo) // path -&gt; page
        childrenMap := make(map[string][]string)  // parent path -&gt; child paths

        // First, index all pages and determine parent-child relationships
        for i := range pages </span><span class="cov8" title="1">{
                page := &amp;pages[i]

                if page.IsDirectory </span><span class="cov8" title="1">{
                        // For directory pages, use the directory path as the key
                        pageMap[page.FilePath] = page

                        // Determine parent directory for nested directories
                        if strings.Contains(page.FilePath, string(filepath.Separator)) </span><span class="cov8" title="1">{
                                parentDir := filepath.Dir(page.FilePath)
                                if parentDir != "." </span><span class="cov8" title="1">{
                                        page.ParentPath = parentDir
                                        childrenMap[parentDir] = append(childrenMap[parentDir], page.FilePath)
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        // For file pages, use the file path as the key
                        pageMap[page.FilePath] = page

                        // Determine parent directory for file pages
                        relPath, err := filepath.Rel(s.config.Local.MarkdownDir, page.FilePath)
                        if err != nil </span><span class="cov0" title="0">{
                                relPath = page.FilePath
                        }</span>

                        <span class="cov8" title="1">dir := filepath.Dir(relPath)
                        if dir != "." </span><span class="cov8" title="1">{
                                page.ParentPath = dir
                                childrenMap[dir] = append(childrenMap[dir], page.FilePath)
                        }</span>
                }
        }

        // Build tree recursively
        <span class="cov8" title="1">var buildChildren func(string) []PageSyncInfo
        buildChildren = func(parentPath string) []PageSyncInfo </span><span class="cov8" title="1">{
                var children []PageSyncInfo
                if childPaths, exists := childrenMap[parentPath]; exists </span><span class="cov8" title="1">{
                        for _, childPath := range childPaths </span><span class="cov8" title="1">{
                                if childPage, exists := pageMap[childPath]; exists </span><span class="cov8" title="1">{
                                        // Create a copy of the child page
                                        child := *childPage
                                        // Recursively build children for this child
                                        child.Children = buildChildren(childPath)
                                        children = append(children, child)
                                }</span>
                        }
                }
                <span class="cov8" title="1">return children</span>
        }

        // Find root pages and build their children
        <span class="cov8" title="1">var rootPages []PageSyncInfo
        for _, page := range pageMap </span><span class="cov8" title="1">{
                if page.ParentPath == "" || pageMap[page.ParentPath] == nil </span><span class="cov8" title="1">{
                        rootPage := *page
                        rootPage.Children = buildChildren(page.FilePath)
                        rootPages = append(rootPages, rootPage)
                }</span>
        }

        <span class="cov8" title="1">return rootPages</span>
}

func (s *Syncer) printEnhancedPageTree(pages []PageSyncInfo, level int) <span class="cov8" title="1">{
        for i, page := range pages </span><span class="cov8" title="1">{
                isLast := i == len(pages)-1

                // Build prefix with proper tree formatting
                prefix := ""
                for j := 0; j &lt; level; j++ </span><span class="cov8" title="1">{
                        prefix += "  "
                }</span>
                <span class="cov8" title="1">if level &gt; 0 </span><span class="cov8" title="1">{
                        if isLast </span><span class="cov8" title="1">{
                                prefix += "‚îî‚îÄ‚îÄ "
                        }</span> else<span class="cov8" title="1"> {
                                prefix += "‚îú‚îÄ‚îÄ "
                        }</span>
                }

                // Choose icon and status text based on status and type
                <span class="cov8" title="1">var icon, statusText string
                if page.IsDirectory </span><span class="cov8" title="1">{
                        icon = "üìÅ"
                        statusText = " (directory page)"
                }</span> else<span class="cov8" title="1"> {
                        switch page.Status </span>{
                        case StatusNew:<span class="cov8" title="1">
                                icon = "üÜï"
                                statusText = " (new)"</span>
                        case StatusChanged:<span class="cov0" title="0">
                                icon = "üìù"
                                statusText = " (modified)"</span>
                        case StatusUpToDate:<span class="cov8" title="1">
                                icon = "‚úÖ"
                                statusText = " (up-to-date)"</span>
                        default:<span class="cov0" title="0">
                                icon = "üìÑ"
                                statusText = ""</span>
                        }
                }

                // Print the page with file path for non-directory pages
                <span class="cov8" title="1">if page.IsDirectory </span><span class="cov8" title="1">{
                        fmt.Printf("%s%s %s%s\n", prefix, icon, page.Title, statusText)
                }</span> else<span class="cov8" title="1"> {
                        relPath, err := filepath.Rel(s.config.Local.MarkdownDir, page.FilePath)
                        if err != nil </span><span class="cov0" title="0">{
                                // Fallback to filename if relative path calculation fails
                                relPath = filepath.Base(page.FilePath)
                        }</span>
                        <span class="cov8" title="1">fmt.Printf("%s%s %s%s\n", prefix, icon, page.Title, statusText)
                        if level == 0 </span><span class="cov8" title="1">{
                                fmt.Printf("%s    %s %s\n", prefix, icon, relPath)
                        }</span>
                }

                // Recursively print children
                <span class="cov8" title="1">if len(page.Children) &gt; 0 </span><span class="cov8" title="1">{
                        s.printEnhancedPageTree(page.Children, level+1)
                }</span>
        }
}

func (s *Syncer) performEnhancedSync(pages []PageSyncInfo) error <span class="cov8" title="1">{
        s.logger.Info("Starting enhanced sync process...")

        var syncedCount, skippedCount, errorCount int

        // Build a map of page info for easy lookup
        pageInfoMap := make(map[string]PageSyncInfo)
        for _, page := range pages </span><span class="cov8" title="1">{
                pageInfoMap[page.FilePath] = page
        }</span>

        // Extract all files for directory hash calculation
        <span class="cov8" title="1">var allFiles []string
        for _, page := range pages </span><span class="cov8" title="1">{
                if !page.IsDirectory </span><span class="cov8" title="1">{
                        allFiles = append(allFiles, page.FilePath)
                }</span>
        }

        // Extract directory paths for discovery
        <span class="cov8" title="1">var directories []string
        for _, page := range pages </span><span class="cov8" title="1">{
                if page.IsDirectory </span><span class="cov8" title="1">{
                        directories = append(directories, page.FilePath)
                }</span>
        }

        // Discover existing directory pages to improve parent resolution
        <span class="cov8" title="1">discoveredPages := s.discoverExistingPages(directories)

        // First create directory pages
        directoryPages := make(map[string]*confluence.Page)

        // Pre-populate with discovered pages
        for dirPath, page := range discoveredPages </span><span class="cov0" title="0">{
                directoryPages[dirPath] = page
        }</span>

        <span class="cov8" title="1">dirCount := 0
        for _, page := range pages </span><span class="cov8" title="1">{
                if page.IsDirectory </span><span class="cov8" title="1">{
                        dirCount++
                }</span>
        }
        <span class="cov8" title="1">s.logger.Debug("Found %d directory pages to process", dirCount)

        for _, page := range pages </span><span class="cov8" title="1">{
                if !page.IsDirectory </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Extract directory path for directory pages
                <span class="cov8" title="1">dirPath := page.FilePath
                parentDir := filepath.Dir(dirPath)
                if parentDir == "." || parentDir == s.config.Local.MarkdownDir </span><span class="cov8" title="1">{
                        parentDir = ""
                }</span>

                <span class="cov8" title="1">s.logger.Debug("Processing directory: %s with status: %s", dirPath, page.Status)

                // Skip if directory is up-to-date
                if page.Status == StatusUpToDate </span><span class="cov0" title="0">{
                        s.logger.Debug("Skipping up-to-date directory: %s", dirPath)

                        // Check if we already have it from discovery
                        if existingPage := s.findPageFromDiscoveredCache(dirPath, discoveredPages); existingPage != nil </span><span class="cov0" title="0">{
                                directoryPages[dirPath] = existingPage
                        }</span> else<span class="cov0" title="0"> if pageID := s.metadata.GetDirectoryPageID(dirPath); pageID != "" </span><span class="cov0" title="0">{
                                // Fallback to direct page lookup
                                if existingPage, err := s.confluence.GetPage(pageID); err == nil </span><span class="cov0" title="0">{
                                        directoryPages[dirPath] = existingPage
                                }</span>
                        }
                        <span class="cov0" title="0">skippedCount++
                        continue</span>
                }

                <span class="cov8" title="1">s.logger.Debug("Creating/updating directory page for: %s (status: %s)", dirPath, page.Status)
                confluencePage, err := s.createDirectoryPage(dirPath, parentDir, directoryPages, page.Status, allFiles)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to create directory page for %s: %v", dirPath, err)
                        errorCount++
                        continue</span>
                }
                <span class="cov8" title="1">directoryPages[dirPath] = confluencePage
                s.logger.Info("Successfully processed directory page: %s (ID: %s)", dirPath, confluencePage.ID)
                syncedCount++</span>
        }

        // Then sync markdown files
        <span class="cov8" title="1">for _, page := range pages </span><span class="cov8" title="1">{
                if page.IsDirectory </span><span class="cov8" title="1">{
                        continue</span> // Already handled above
                }

                <span class="cov8" title="1">if page.Status == StatusUpToDate </span><span class="cov0" title="0">{
                        s.logger.Debug("Skipping up-to-date file: %s", page.Title)
                        skippedCount++
                        continue</span>
                }

                <span class="cov8" title="1">err := s.syncFileWithMetadata(page.FilePath, directoryPages)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to sync file %s: %v", page.FilePath, err)
                        errorCount++
                        continue</span>
                }
                <span class="cov8" title="1">syncedCount++</span>
        }

        // Save metadata cache
        <span class="cov8" title="1">if err := s.metadata.Save(); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to save sync metadata: %v", err)
        }</span>

        // Display results
        <span class="cov8" title="1">fmt.Printf("\n‚ú® Sync completed!\n")
        fmt.Printf("   ‚úÖ Synced: %d pages\n", syncedCount)
        fmt.Printf("   ‚è≠Ô∏è  Skipped: %d pages (up-to-date)\n", skippedCount)
        if errorCount &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("   ‚ùå Errors: %d pages\n", errorCount)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *Syncer) syncFileWithMetadata(filePath string, directoryPages map[string]*confluence.Page) error <span class="cov8" title="1">{
        s.logger.Info("Syncing file with metadata tracking: %s", filePath)

        doc, err := markdown.ParseFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse markdown: %w", err)
        }</span>

        // Convert content with mermaid and image support
        <span class="cov8" title="1">pageID := s.metadata.GetPageID(filePath)
        var confluenceContent string
        if concreteClient, ok := s.confluence.(*confluence.Client); ok </span><span class="cov0" title="0">{
                var convErr error
                confluenceContent, convErr = markdown.ConvertToConfluenceFormatWithImages(doc.Content, s.config, concreteClient, pageID, filePath)
                if convErr != nil </span><span class="cov0" title="0">{
                        s.logger.Debug("Error processing images, falling back to mermaid-only processing: %v", convErr)
                        confluenceContent = markdown.ConvertToConfluenceFormatWithMermaid(doc.Content, s.config, concreteClient, pageID)
                }</span>
        } else<span class="cov8" title="1"> {
                confluenceContent = markdown.ConvertToConfluenceFormat(doc.Content)
        }</span>

        // Determine parent page based on directory structure
        <span class="cov8" title="1">relPath, err := filepath.Rel(s.config.Local.MarkdownDir, filePath)
        if err != nil </span><span class="cov0" title="0">{
                relPath = filePath
        }</span>

        <span class="cov8" title="1">dir := filepath.Dir(relPath)
        var parentID string
        if dir != "." </span><span class="cov8" title="1">{
                if parentPage, exists := directoryPages[dir]; exists </span><span class="cov8" title="1">{
                        parentID = parentPage.ID
                }</span>
        }

        <span class="cov8" title="1">var page *confluence.Page

        // Use enhanced fallback lookup for existing pages
        cachedPageID := s.metadata.GetPageID(filePath)
        existingPage, err := s.findPageWithFallback(doc.Title, cachedPageID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Could not check for existing page (will create new): %s", doc.Title)
        }</span>

        <span class="cov8" title="1">if existingPage != nil </span><span class="cov8" title="1">{
                s.logger.Info("Updating existing page: %s", doc.Title)
                page, err = s.confluence.UpdatePage(existingPage.ID, doc.Title, confluenceContent)

                // Handle archived/restricted page (403 error) by attempting replacement
                if confluence.IsPageUpdateForbidden(err) </span><span class="cov8" title="1">{
                        s.logger.Info("Page appears to be archived or restricted, attempting to replace: %s", doc.Title)

                        // Clear the cached page ID for this file to avoid future conflicts
                        s.metadata.RemoveFileMetadata(filePath)

                        page, err = s.handleArchivedPageReplacement(doc.Title, confluenceContent, parentID, existingPage.ID)
                }</span>
        } else<span class="cov8" title="1"> {
                s.logger.Info("Creating new page: %s", doc.Title)
                if parentID != "" </span><span class="cov8" title="1">{
                        page, err = s.confluence.CreatePageWithParent(s.config.Confluence.SpaceKey, doc.Title, confluenceContent, parentID)
                }</span> else<span class="cov8" title="1"> {
                        page, err = s.confluence.CreatePage(s.config.Confluence.SpaceKey, doc.Title, confluenceContent)
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sync page: %w", err)
        }</span>

        // Post-process diagrams and images for the created/updated page
        <span class="cov8" title="1">if (s.config.Mermaid.Mode == "convert-to-image" &amp;&amp; s.hasMermaidDiagrams(doc.Content)) || s.hasImages(doc.Content) </span><span class="cov0" title="0">{
                s.logger.Info("Post-processing diagrams and images for page: %s", doc.Title)
                err = s.postProcessPageContent(page.ID, doc.Content, filePath)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to post-process content for %s: %v", doc.Title, err)
                        // Don't fail the entire sync for processing errors
                }</span>
        }

        // Update metadata with successful sync
        <span class="cov8" title="1">if err := s.metadata.UpdateFileMetadata(filePath, page.ID, doc.Title); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update metadata for %s: %v", filePath, err)
        }</span>

        <span class="cov8" title="1">s.logger.Info("Successfully synced: %s (ID: %s)", doc.Title, page.ID)
        return nil</span>
}

func (s *Syncer) ClearCache() error <span class="cov8" title="1">{
        return s.metadata.ClearCache()
}</span>

// DetectRenamesOnly runs only the rename detection analysis without performing sync
func (s *Syncer) DetectRenamesOnly() error <span class="cov0" title="0">{
        s.logger.Info("Running rename detection analysis...")

        // Load sync metadata cache
        if err := s.metadata.Load(); err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Could not load sync cache: %v", err)
                fmt.Println("‚ùå No sync cache found. Run a sync first to build the cache, then rename detection will be available.")
                return nil
        }</span>

        // Find markdown files
        <span class="cov0" title="0">files, err := markdown.FindMarkdownFiles(s.config.Local.MarkdownDir, s.config.Local.Exclude)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find markdown files: %w", err)
        }</span>

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                fmt.Println("üìÇ No markdown files found in the specified directory.")
                return nil
        }</span>

        <span class="cov0" title="0">s.logger.Info("Analyzing %d markdown files for rename detection", len(files))

        // Analyze files for rename detection (skip change detection)
        pages, err := s.analyzeAllFiles(files, false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to analyze files: %w", err)
        }</span>

        // Run rename detection analysis
        <span class="cov0" title="0">renameDetections, err := s.DetectRenames(pages)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("rename detection analysis failed: %w", err)
        }</span>

        <span class="cov0" title="0">if len(renameDetections) == 0 </span><span class="cov0" title="0">{
                fmt.Println("‚úÖ No rename issues detected!")
                fmt.Printf("üìä Analyzed %d files and %d directories - all titles match expectations.\n",
                        len(files), len(s.extractDirectories(files)))
        }</span> else<span class="cov0" title="0"> {
                s.DisplayRenameDetections(renameDetections)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// hasMermaidDiagrams checks if the content contains any Mermaid diagram blocks
func (s *Syncer) hasMermaidDiagrams(content string) bool <span class="cov8" title="1">{
        return strings.Contains(content, "```mermaid")
}</span>

// hasImages checks if the content contains any image references
func (s *Syncer) hasImages(content string) bool <span class="cov8" title="1">{
        return strings.Contains(content, "![")
}</span>

// handleArchivedPageReplacement handles the case where an existing page is archived/restricted
// and we need to replace it with a new page with the same title
func (s *Syncer) handleArchivedPageReplacement(title, content, parentID, existingPageID string) (*confluence.Page, error) <span class="cov8" title="1">{
        // Attempt to create replacement page with original title
        s.logger.Info("Attempting to create replacement page: %s", title)
        var page *confluence.Page
        var err error

        if parentID != "" </span><span class="cov0" title="0">{
                page, err = s.confluence.CreatePageWithParent(s.config.Confluence.SpaceKey, title, content, parentID)
        }</span> else<span class="cov8" title="1"> {
                page, err = s.confluence.CreatePage(s.config.Confluence.SpaceKey, title, content)
        }</span>

        // If we get a "title already exists" error, try with a timestamp suffix
        <span class="cov8" title="1">if err != nil &amp;&amp; (strings.Contains(err.Error(), "already exists") || strings.Contains(err.Error(), "TITLE")) </span><span class="cov8" title="1">{
                s.logger.Info("Title conflict detected, creating page with timestamp suffix: %s", title)
                timestampSuffix := fmt.Sprintf(" (replaced %s)", time.Now().Format("2006-01-02 15:04"))
                newTitle := title + timestampSuffix

                if parentID != "" </span><span class="cov0" title="0">{
                        page, err = s.confluence.CreatePageWithParent(s.config.Confluence.SpaceKey, newTitle, content, parentID)
                }</span> else<span class="cov8" title="1"> {
                        page, err = s.confluence.CreatePage(s.config.Confluence.SpaceKey, newTitle, content)
                }</span>

                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        s.logger.Info("Successfully created replacement page with new title: %s", newTitle)
                }</span> else<span class="cov0" title="0"> {
                        s.logger.Error("Failed to create replacement page even with timestamp suffix: %v", err)
                }</span>
        } else<span class="cov0" title="0"> if err == nil </span><span class="cov0" title="0">{
                s.logger.Info("Successfully created replacement page: %s", title)
        }</span> else<span class="cov0" title="0"> {
                s.logger.Error("Failed to create replacement page: %v", err)
        }</span>

        <span class="cov8" title="1">return page, err</span>
}

// postProcessPageContent re-processes a page to convert Mermaid diagrams and images
// This is called after page creation when we have a pageID for attachment uploads
func (s *Syncer) postProcessPageContent(pageID, content, filePath string) error <span class="cov0" title="0">{
        s.logger.Debug("Post-processing page content for page ID: %s", pageID)

        // Re-convert content with the actual pageID for Mermaid and image processing
        var updatedContent string
        var err error
        if concreteClient, ok := s.confluence.(*confluence.Client); ok </span><span class="cov0" title="0">{
                updatedContent, err = markdown.ConvertToConfluenceFormatWithImages(content, s.config, concreteClient, pageID, filePath)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Debug("Error processing images, falling back to mermaid-only processing: %v", err)
                        updatedContent = markdown.ConvertToConfluenceFormatWithMermaid(content, s.config, concreteClient, pageID)
                }</span>
        } else<span class="cov0" title="0"> {
                updatedContent = markdown.ConvertToConfluenceFormat(content)
        }</span>

        // Get current page info to preserve title
        <span class="cov0" title="0">page, err := s.confluence.GetPage(pageID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get page info for post-processing: %w", err)
        }</span>

        // Update the page with processed diagrams and images
        <span class="cov0" title="0">_, err = s.confluence.UpdatePage(pageID, page.Title, updatedContent)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update page with processed content: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Successfully post-processed content for page: %s", page.Title)
        return nil</span>
}

// processImagesWithTracking processes images in markdown content with attachment tracking
func (s *Syncer) processImagesWithTracking(content, pageID, filePath string) (string, error) <span class="cov0" title="0">{
        if concreteClient, ok := s.confluence.(*confluence.Client); !ok </span><span class="cov0" title="0">{
                return content, nil
        }</span> else<span class="cov0" title="0"> {
                // Create image processor
                imageProcessor := images.NewProcessor(&amp;s.config.Images, s.logger)

                // Get directory of the markdown file to resolve relative image paths
                markdownDir := filepath.Dir(filePath)

                // Find image references in the original markdown content
                imageRefs, err := imageProcessor.FindImageReferences(content, markdownDir)
                if err != nil </span><span class="cov0" title="0">{
                        return content, fmt.Errorf("failed to find image references: %w", err)
                }</span>

                // Validate image references
                <span class="cov0" title="0">validRefs, err := imageProcessor.ValidateImageReferences(imageRefs)
                if err != nil </span><span class="cov0" title="0">{
                        return content, fmt.Errorf("failed to validate image references: %w", err)
                }</span>

                // Process each valid image reference
                <span class="cov0" title="0">updatedContent := content
                for _, ref := range validRefs </span><span class="cov0" title="0">{
                        filename := images.GetImageFilename(ref.AbsolutePath)

                        // Calculate hash of the image file
                        currentHash, err := images.CalculateImageHash(ref.AbsolutePath)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Debug("Failed to calculate hash for image %s: %v", ref.AbsolutePath, err)
                                continue</span>
                        }

                        // Check if attachment has changed
                        <span class="cov0" title="0">if !s.metadata.AttachmentChanged(filePath, filename, currentHash) </span><span class="cov0" title="0">{
                                s.logger.Debug("Image %s unchanged, skipping upload", filename)
                                // Attachment hasn't changed, just replace with macro
                                confluenceImageMacro := fmt.Sprintf(`&lt;ac:image&gt;&lt;ri:attachment ri:filename="%s"/&gt;&lt;/ac:image&gt;`, filename)
                                updatedContent = strings.ReplaceAll(updatedContent, ref.MarkdownSyntax, confluenceImageMacro)
                                continue</span>
                        }

                        <span class="cov0" title="0">s.logger.Debug("Uploading new/changed image: %s", filename)
                        // Upload image as attachment (new or changed)
                        attachment, err := concreteClient.UploadAttachment(pageID, ref.AbsolutePath)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Debug("Failed to upload image %s: %v", filename, err)
                                continue</span>
                        }

                        // Determine the filename for the attachment reference
                        <span class="cov0" title="0">attachmentFilename := attachment.Title
                        if attachmentFilename == "" </span><span class="cov0" title="0">{
                                attachmentFilename = attachment.Title
                        }</span>
                        <span class="cov0" title="0">if attachmentFilename == "" </span><span class="cov0" title="0">{
                                attachmentFilename = filename
                        }</span>

                        // Update attachment tracking
                        <span class="cov0" title="0">s.metadata.UpdateFileAttachment(filePath, filename, currentHash)

                        // Replace the markdown image syntax with Confluence image macro
                        confluenceImageMacro := fmt.Sprintf(`&lt;ac:image&gt;&lt;ri:attachment ri:filename="%s"/&gt;&lt;/ac:image&gt;`, attachmentFilename)
                        updatedContent = strings.ReplaceAll(updatedContent, ref.MarkdownSyntax, confluenceImageMacro)</span>
                }

                <span class="cov0" title="0">return updatedContent, nil</span>
        }
}

// generateTitleVariations creates different title variations for fuzzy matching
func (s *Syncer) generateTitleVariations(originalName string) []string <span class="cov8" title="1">{
        caser := cases.Title(language.English)
        variations := []string{
                originalName, // Original form (e.g., "my-notebook")
                caser.String(strings.ReplaceAll(originalName, "-", " ")), // Transform dashes to spaces and title case
                caser.String(strings.ReplaceAll(originalName, "_", " ")), // Transform underscores to spaces and title case
                strings.ReplaceAll(originalName, "-", " "),               // Dashes to spaces, no case change
                strings.ReplaceAll(originalName, "_", " "),               // Underscores to spaces, no case change
                caser.String(originalName),                               // Title case of original
                strings.ToUpper(originalName),                            // All uppercase
                strings.ToLower(originalName),                            // All lowercase
        }

        // Remove duplicates while preserving order
        seen := make(map[string]bool)
        var uniqueVariations []string
        for _, variation := range variations </span><span class="cov8" title="1">{
                if !seen[variation] &amp;&amp; variation != "" </span><span class="cov8" title="1">{
                        seen[variation] = true
                        uniqueVariations = append(uniqueVariations, variation)
                }</span>
        }

        <span class="cov8" title="1">return uniqueVariations</span>
}

// findPageWithFallback attempts to find a page using multiple strategies
func (s *Syncer) findPageWithFallback(originalName, cachedPageID string) (*confluence.Page, error) <span class="cov8" title="1">{
        // Strategy 1: Try cached page ID lookup
        if cachedPageID != "" </span><span class="cov8" title="1">{
                s.logger.Debug("Trying cached page ID lookup: %s", cachedPageID)
                if existingPage, err := s.confluence.GetPage(cachedPageID); err == nil &amp;&amp; existingPage != nil </span><span class="cov8" title="1">{
                        s.logger.Debug("Found page via cached ID: %s", existingPage.Title)

                        // Check if page title has changed and log it
                        if existingPage.Title != originalName </span><span class="cov8" title="1">{
                                s.logger.Info("Page title has changed from '%s' to '%s' (ID: %s)", originalName, existingPage.Title, existingPage.ID)
                        }</span>

                        <span class="cov8" title="1">return existingPage, nil</span>
                }
                <span class="cov0" title="0">s.logger.Debug("Cached page ID lookup failed, trying title variations")</span>
        }

        // Strategy 2: Try exact title match (current behavior)
        <span class="cov8" title="1">s.logger.Debug("Trying exact title match for: %s", originalName)
        if existingPage, err := s.confluence.FindPageByTitle(s.config.Confluence.SpaceKey, originalName); err == nil &amp;&amp; existingPage != nil </span><span class="cov8" title="1">{
                s.logger.Debug("Found page via exact title match: %s", existingPage.Title)
                return existingPage, nil
        }</span>

        // Strategy 3: Try fuzzy matching with title variations
        <span class="cov8" title="1">variations := s.generateTitleVariations(originalName)
        s.logger.Debug("Trying %d title variations for: %s", len(variations), originalName)

        for _, variation := range variations </span><span class="cov8" title="1">{
                if variation == originalName </span><span class="cov8" title="1">{
                        continue</span> // Already tried exact match
                }

                <span class="cov8" title="1">s.logger.Debug("Trying title variation: %s", variation)
                if existingPage, err := s.confluence.FindPageByTitle(s.config.Confluence.SpaceKey, variation); err == nil &amp;&amp; existingPage != nil </span><span class="cov0" title="0">{
                        s.logger.Info("Found page via title variation '%s' for original name '%s': %s", variation, originalName, existingPage.Title)
                        return existingPage, nil
                }</span>
        }

        <span class="cov8" title="1">s.logger.Debug("No existing page found for: %s", originalName)
        return nil, nil</span>
}

// preloadExistingPages optionally tries to discover existing pages for better parent resolution
// Since we're limited by the interface, this is a lighter approach that still helps
func (s *Syncer) discoverExistingPages(directories []string) map[string]*confluence.Page <span class="cov8" title="1">{
        s.logger.Debug("Discovering existing directory pages in Confluence")

        discoveredPages := make(map[string]*confluence.Page)

        // Try to find pages for each directory using fuzzy matching
        for _, dirPath := range directories </span><span class="cov8" title="1">{
                dirName := filepath.Base(dirPath)
                cachedPageID := s.metadata.GetDirectoryPageID(dirPath)

                if page, err := s.findPageWithFallback(dirName, cachedPageID); err == nil &amp;&amp; page != nil </span><span class="cov0" title="0">{
                        discoveredPages[dirPath] = page
                        s.logger.Debug("Discovered existing directory page: %s -&gt; %s", dirPath, page.Title)
                }</span>
        }

        <span class="cov8" title="1">s.logger.Info("Discovered %d existing directory pages", len(discoveredPages))
        return discoveredPages</span>
}

// findPageFromDiscoveredCache looks up a page from the discovered cache
func (s *Syncer) findPageFromDiscoveredCache(dirPath string, discoveredPages map[string]*confluence.Page) *confluence.Page <span class="cov0" title="0">{
        if discoveredPages == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if page, exists := discoveredPages[dirPath]; exists </span><span class="cov0" title="0">{
                return page
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package logger

import (
        "fmt"
        "log"
        "os"
)

type Logger struct {
        verbose bool
        logger  *log.Logger
}

func New(verbose bool) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                verbose: verbose,
                logger:  log.New(os.Stdout, "", log.LstdFlags),
        }
}</span>

func (l *Logger) Info(format string, args ...interface{}) <span class="cov8" title="1">{
        l.logger.Printf("[INFO] "+format, args...)
}</span>

func (l *Logger) Debug(format string, args ...interface{}) <span class="cov8" title="1">{
        if l.verbose </span><span class="cov8" title="1">{
                l.logger.Printf("[DEBUG] "+format, args...)
        }</span>
}

func (l *Logger) Error(format string, args ...interface{}) <span class="cov8" title="1">{
        l.logger.Printf("[ERROR] "+format, args...)
}</span>

func (l *Logger) Fatal(format string, args ...interface{}) <span class="cov0" title="0">{
        l.logger.Printf("[FATAL] "+format, args...)
        os.Exit(1)
}</span>

func (l *Logger) Print(v ...interface{}) <span class="cov8" title="1">{
        fmt.Print(v...)
}</span>

func (l *Logger) Printf(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Printf(format, args...)
}</span>

func (l *Logger) Println(v ...interface{}) <span class="cov8" title="1">{
        fmt.Println(v...)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package version

import (
        "fmt"
        "runtime"
)

// Version information. These will be set by build flags.
var (
        Version   = "dev"
        GitCommit = ""
        BuildDate = ""
)

// BuildInfo contains detailed version information
type BuildInfo struct {
        Version   string
        GitCommit string
        BuildDate string
        GoVersion string
        Platform  string
}

// Get returns the current build information
func Get() BuildInfo <span class="cov8" title="1">{
        return BuildInfo{
                Version:   Version,
                GitCommit: GitCommit,
                BuildDate: BuildDate,
                GoVersion: runtime.Version(),
                Platform:  fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH),
        }
}</span>

// String returns a formatted version string
func (b BuildInfo) String() string <span class="cov8" title="1">{
        result := fmt.Sprintf("conflux version %s", b.Version)

        if b.GitCommit != "" </span><span class="cov8" title="1">{
                result += fmt.Sprintf(" (%s)", b.GitCommit)
        }</span>

        <span class="cov8" title="1">if b.BuildDate != "" </span><span class="cov8" title="1">{
                result += fmt.Sprintf(" built on %s", b.BuildDate)
        }</span>

        <span class="cov8" title="1">result += fmt.Sprintf(" %s %s", b.GoVersion, b.Platform)

        return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
